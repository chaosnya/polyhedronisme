// Polyhédronisme
// ===================================================================================================
//
// A toy for constructing and manipulating polyhedra.
//
// Copyright 2019, Anselm Levskaya
// Released under the MIT License
//

// Export / Formatting Routines --------------------------------------------------

/* eslint-disable camelcase */
/* eslint-disable standard/array-bracket-even-spacing */
/* eslint-disable no-multi-spaces */
import { normal } from './geo';
import { palette } from './polyhedron';

const vertColors = function (poly) {
  const vertcolors = [];
  for (let i = 0; i < poly.faces.length; i++) {
    const face = poly.faces[i];
    for (let v of face) {
      vertcolors[v] = poly.face_classes[i];
    }
  }
  return vertcolors;
};

// produces vanilla OBJ files for import into 3d apps
export const toOBJ = function (poly) {
  let f;
  let v;
  let objstr = '#Produced by polyHédronisme http://levskaya.github.com/polyhedronisme\n';
  objstr += `group ${poly.name}\n`;
  objstr += '#vertices\n';
  for (v of poly.vertices) {
    objstr += `v ${v[0]} ${v[1]} ${v[2]}\n`;
  }
  objstr += '#normal vector defs \n';
  for (f of poly.faces) {
    const norm = normal(f.map(v => poly.vertices[v]))
    objstr += `vn ${norm[0]} ${norm[1]} ${norm[2]}\n`;
  }
  objstr += '#face defs \n';
  for (let i = 0; i < poly.faces.length; i++) {
    f = poly.faces[i];
    objstr += 'f ';
    for (v of f) {
      objstr += `${v + 1}//${i + 1} `;
    }
    objstr += '\n';
  }
  return objstr;
};

export const toX3D = function (poly) {
  let v;
  // ShapeWays uses 1unit = 1meter, so reduce to 3cm scale
  const SCALE_FACTOR = 0.03;
  // opening cruft
  let x3dstr = `\
<?xml version="1.0" encoding ="UTF-8"?>
<X3D profile="Interchange" version="3.0">
<head>
<component name="Rendering" level="3"/>
<meta name="generator" content="Polyhedronisme"/>
<meta name="version" content="0.1.0"/>
</head>
<Scene>
<Shape>
<IndexedFaceSet normalPerVertex="false" coordIndex="\
`;
    // face indices
  for (let f of poly.faces) {
    for (v of f) {
      x3dstr += `${v} `;
    }
    x3dstr += '-1\n';
  }
  x3dstr += '">\n';

  // per-face Color
  x3dstr += '<Color color="';
  for (let cl of vertColors(this)) { // @face_class
    const clr = palette(cl);
    x3dstr += `${clr[0]} ${clr[1]} ${clr[2]} `;
  }
  x3dstr += '"/>';

  // re-scaled xyz coordinates
  x3dstr += '<Coordinate point="';
  for (v of poly.vertices) {
    x3dstr += `${v[0] * SCALE_FACTOR} ${v[1] * SCALE_FACTOR} ${v[2] * SCALE_FACTOR} `;
  }
  x3dstr += '"/>\n';

  // end cruft
  x3dstr += `\
</IndexedFaceSet>
</Shape>
</Scene>
</X3D>`;

  return x3dstr;
};

export const toVRML = function (poly) {
  let v;
  // ShapeWays uses 1unit = 1meter, so reduce to 3cm scale
  const SCALE_FACTOR = 0.03;
  // opening cruft
  let x3dstr = `\
#VRML V2.0 utf8
#Generated by Polyhedronisme
NavigationInfo {
  type [ "EXAMINE", "ANY" ]
}
Transform {
  scale 1 1 1
  translation 0 0 0
  children
  [
    Shape
    {
      geometry IndexedFaceSet
      {
        creaseAngle .5
        solid FALSE
        coord Coordinate
        {
          point
          [\
`;
    // re-scaled xyz coordinates
  for (v of poly.vertices) {
    x3dstr += `${v[0] * SCALE_FACTOR} ${v[1] * SCALE_FACTOR} ${v[2] * SCALE_FACTOR},`;
  }
  x3dstr = x3dstr.slice(0, +-2 + 1 || undefined);
  x3dstr += `\
    ]
}
color Color
{
  color
  [\
`;
  // per-face Color
  for (let cl of poly.face_classes) {
    const clr = palette(cl);
    x3dstr += `${clr[0]} ${clr[1]} ${clr[2]} ,`;
  }
  x3dstr = x3dstr.slice(0, +-2 + 1 || undefined);
  x3dstr += `\
  ]
}
colorPerVertex FALSE
coordIndex
[\
`;
  // face indices
  for (let f of poly.faces) {
    for (v of f) {
      x3dstr += `${v}, `;
    }
    x3dstr += '-1,';
  }
  x3dstr = x3dstr.slice(0, +-2 + 1 || undefined);
  x3dstr += `\
          ]
      }
      appearance Appearance
      {
        material Material
        {
         ambientIntensity 0.2
         diffuseColor 0.9 0.9 0.9
         specularColor .1 .1 .1
         shininess .5
        }
      }
    }
  ]
}\
`;
  return x3dstr;
}
