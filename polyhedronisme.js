// Generated by CoffeeScript 1.6.2
(function() {
  var AminusB, BG_CLEAR, BG_COLOR, CANVAS_HEIGHT, CANVAS_WIDTH, COLOR_METHOD, DEFAULT_RECIPES, LN10, LastMouseX, LastMouseY, LastSphVec, MOUSEDOWN, PALETTE, PEG_parser_spec, PI, PaintMode, Signed2DTriArea, Test2DSegmentSegment, abs, acos, add, add2D, adjustXYZ, ambo, animateShape, antiprism, asin, atan, basemap, calcCentroid, calcExtents, calcPerspExtents, canonicalXYZ, canonicalize, chop, clear, clockwisepoly, clone, convexarea, copyVecArray, cos, cross, cross2D, ctx, ctx_linewidth, cube, diagsToTris, dispatch, dodecahedron, dot, dot2D, drawShape, drawpoly, dual, edgeDist, extrudeN, eye3, faceSignature, faceToEdges, facesidedness, floor, getDiagonals, getOps, getSVG, getVec2VecRotM, globPolys, globRotM, globlastRotM, globtime, gyro, hextofloats, hollow, icosahedron, idxof, init, insetN, intersect, intersectionGraph, invperspT, kisN, lineIsect2D, log, log10, mag, mag2, midpoint, mm3, mult, mv3, newgeneratePoly, normal, octahedron, oneThird, op_parser, opmap, orthogonal, paintPolyhedron, palette, parseurl, perspT, persp_ratio, persp_z_max, persp_z_min, perspective_scale, planarize, pointInPoly, polyflag, polygonIsectTest, polygonclip, polyhedron, pow, prism, project2dface, propellor, pyramid, random, randomchoice, recenter, reciprocal, reciprocalC, reciprocalN, reflect, rescale, rotm, round, rwb_palette, saveText, sigfigs, sin, sortfaces, sortfaces_fancy, sortfaces_fancy2, specreplacements, sqrt, stellaN, sub, sub2D, tan, tangentPoint, tangentify, testrig, tetrahedron, to2Dfaces, topolog, triEq, triangulate, tween, twoDpolygonarea, unit, vec_rotm, vertColors, _2d_x_offset, _2d_y_offset, _mult;

  random = Math.random;

  round = Math.round;

  floor = Math.floor;

  sqrt = Math.sqrt;

  sin = Math.sin;

  cos = Math.cos;

  tan = Math.tan;

  asin = Math.asin;

  acos = Math.acos;

  atan = Math.atan;

  pow = Math.pow;

  abs = Math.abs;

  PI = Math.PI;

  LN10 = Math.LN10;

  log = Math.log;

  pow = Math.pow;

  log10 = function(x) {
    return log(x) / LN10;
  };

  sigfigs = function(N, nsigs) {
    var normed;

    normed = pow(10, log10(N) - floor(log10(N)));
    return "" + (round(normed * (nsigs - 1)));
  };

  clone = function(obj) {
    var key, newInstance;

    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  randomchoice = function(array) {
    var n;

    n = floor(random() * array.length);
    return array[n];
  };

  mult = function(c, vec) {
    return [c * vec[0], c * vec[1], c * vec[2]];
  };

  _mult = function(vec1, vec2) {
    return [vec1[0] * vec2[0], vec1[1] * vec2[1], vec1[2] * vec2[2]];
  };

  add = function(vec1, vec2) {
    return [vec1[0] + vec2[0], vec1[1] + vec2[1], vec1[2] + vec2[2]];
  };

  sub = function(vec1, vec2) {
    return [vec1[0] - vec2[0], vec1[1] - vec2[1], vec1[2] - vec2[2]];
  };

  dot = function(vec1, vec2) {
    return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];
  };

  cross = function(d1, d2) {
    return [d1[1] * d2[2] - d1[2] * d2[1], d1[2] * d2[0] - d1[0] * d2[2], d1[0] * d2[1] - d1[1] * d2[0]];
  };

  dot2D = function(vec1, vec2) {
    return vec1[0] * vec2[0] + vec1[1] * vec2[1];
  };

  cross2D = function(d1, d2) {
    return d1[0] * d2[1] - d1[1] * d2[0];
  };

  add2D = function(vec1, vec2) {
    return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
  };

  sub2D = function(vec1, vec2) {
    return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
  };

  chop = function(x) {
    if (abs(x) < 1e-10) {
      return 0;
    } else {
      return x;
    }
  };

  mag = function(vec) {
    return sqrt(dot(vec, vec));
  };

  mag2 = function(vec) {
    return dot(vec, vec);
  };

  unit = function(vec) {
    return mult(1 / sqrt(mag2(vec)), vec);
  };

  midpoint = function(vec1, vec2) {
    return mult(1 / 2.0, add(vec1, vec2));
  };

  tween = function(vec1, vec2, t) {
    return [(1 - t) * vec1[0] + t * vec2[0], (1 - t) * vec1[1] + t * vec2[1], (1 - t) * vec1[2] + t * vec2[2]];
  };

  oneThird = function(vec1, vec2) {
    return tween(vec1, vec2, 1 / 3.0);
  };

  reciprocal = function(vec) {
    return mult(1.0 / mag2(vec), vec);
  };

  tangentPoint = function(v1, v2) {
    var d;

    d = sub(v2, v1);
    return sub(v1, mult(dot(d, v1) / mag2(d), d));
  };

  edgeDist = function(v1, v2) {
    return sqrt(mag2(tangentPoint(v1, v2)));
  };

  orthogonal = function(v1, v2, v3) {
    var d1, d2;

    d1 = sub(v2, v1);
    d2 = sub(v3, v2);
    return cross(d1, d2);
  };

  intersect = function(set1, set2, set3) {
    var s1, s2, s3, _i, _j, _k, _len, _len1, _len2;

    for (_i = 0, _len = set1.length; _i < _len; _i++) {
      s1 = set1[_i];
      for (_j = 0, _len1 = set2.length; _j < _len1; _j++) {
        s2 = set2[_j];
        if (s1 === s2) {
          for (_k = 0, _len2 = set3.length; _k < _len2; _k++) {
            s3 = set3[_k];
            if (s1 === s3) {
              return s1;
            }
          }
        }
      }
    }
    return null;
  };

  calcCentroid = function(xyzs) {
    var centroidV, v, _i, _len;

    centroidV = [0, 0, 0];
    for (_i = 0, _len = xyzs.length; _i < _len; _i++) {
      v = xyzs[_i];
      centroidV = add(centroidV, v);
    }
    return mult(1 / xyzs.length, centroidV);
  };

  normal = function(xyzs) {
    var normalV, v1, v2, v3, _i, _len, _ref, _ref1;

    normalV = [0, 0, 0];
    _ref = xyzs.slice(-2), v1 = _ref[0], v2 = _ref[1];
    for (_i = 0, _len = xyzs.length; _i < _len; _i++) {
      v3 = xyzs[_i];
      normalV = add(normalV, orthogonal(v1, v2, v3));
      _ref1 = [v2, v3], v1 = _ref1[0], v2 = _ref1[1];
    }
    return unit(normalV);
  };

  calcExtents = function(xyzs) {
    var maxX, maxY, maxZ, minX, minY, minZ, v, x, y, z, _i, _len, _ref, _ref1, _ref2, _ref3;

    _ref = xyzs[0], x = _ref[0], y = _ref[1], z = _ref[2];
    _ref1 = [x, x], maxX = _ref1[0], minX = _ref1[1];
    _ref2 = [y, y], maxY = _ref2[0], minY = _ref2[1];
    _ref3 = [z, z], maxZ = _ref3[0], minZ = _ref3[1];
    for (_i = 0, _len = xyzs.length; _i < _len; _i++) {
      v = xyzs[_i];
      x = v[0], y = v[1], z = v[2];
      maxX = maxX < x ? x : maxX;
      minX = minX > x ? x : minX;
      maxY = maxY < y ? y : maxY;
      minY = minY > y ? y : minY;
      maxZ = maxZ < z ? z : maxZ;
      minZ = minZ > z ? z : minZ;
    }
    return [[minX, maxX], [minY, maxY], [minZ, maxZ]];
  };

  calcPerspExtents = function(xyzs, max_real_depth, min_real_depth, desired_ratio, desired_length) {
    var maxX, maxY, maxZ, minX, minY, minZ, pX, pY, v, x, y, z, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

    _ref = xyzs[0], x = _ref[0], y = _ref[1], z = _ref[2];
    _ref1 = perspT(xyzs[0], max_real_depth, min_real_depth, desired_ratio, desired_length), pX = _ref1[0], pY = _ref1[1];
    _ref2 = [pX, pX], maxX = _ref2[0], minX = _ref2[1];
    _ref3 = [pY, pY], maxY = _ref3[0], minY = _ref3[1];
    _ref4 = [z, z], maxZ = _ref4[0], minZ = _ref4[1];
    for (_i = 0, _len = xyzs.length; _i < _len; _i++) {
      v = xyzs[_i];
      x = v[0], y = v[1], z = v[2];
      _ref5 = perspT(v, max_real_depth, min_real_depth, desired_ratio, desired_length), pX = _ref5[0], pY = _ref5[1];
      maxX = maxX < pX ? pX : maxX;
      minX = minX > pX ? pX : minX;
      maxY = maxY < pY ? pY : maxY;
      minY = minY > pY ? pY : minY;
      maxZ = maxZ < z ? z : maxZ;
      minZ = minZ > z ? z : minZ;
    }
    return [[minX, maxX], [minY, maxY], [minZ, maxZ]];
  };

  convexarea = function(xyzs) {
    var area, v1, v2, v3, _i, _len, _ref, _ref1;

    area = 0.0;
    _ref = xyzs.slice(0, 2), v1 = _ref[0], v2 = _ref[1];
    _ref1 = xyzs.slice(2);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      v3 = _ref1[_i];
      area += mag(cross(sub(v2, v1), sub(v3, v1)));
      v2 = v3;
    }
    return area;
  };

  faceSignature = function(xyzs) {
    var cross_array, sig, v1, v2, v3, x, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

    cross_array = [];
    _ref = xyzs.slice(0, 2), v1 = _ref[0], v2 = _ref[1];
    _ref1 = xyzs.slice(2);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      v3 = _ref1[_i];
      cross_array.push(mag(cross(sub(v2, v1), sub(v3, v1))));
      v2 = v3;
    }
    cross_array.sort(function(a, b) {
      return a - b;
    });
    sig = "";
    for (_j = 0, _len1 = cross_array.length; _j < _len1; _j++) {
      x = cross_array[_j];
      sig += sigfigs(x, 2);
    }
    _ref2 = cross_array.reverse();
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      x = _ref2[_k];
      sig += sigfigs(x, 2);
    }
    return sig;
  };

  project2dface = function(verts) {
    var c, n, p, tmpverts, v, v0, _i, _len, _results;

    tmpverts = clone(verts);
    v0 = verts[0];
    tmpverts = _.map(tmpverts, function(x) {
      return x - v0;
    });
    n = normal(verts);
    c = unit(calcCentroid(verts));
    p = cross(n, c);
    _results = [];
    for (_i = 0, _len = tmpverts.length; _i < _len; _i++) {
      v = tmpverts[_i];
      _results.push([dot(n, v), dot(p, v)]);
    }
    return _results;
  };

  copyVecArray = function(vecArray) {
    var i, newVecArray, _i, _ref;

    newVecArray = new Array(vecArray.length);
    for (i = _i = 0, _ref = vecArray.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      newVecArray[i] = vecArray[i].slice(0);
    }
    return newVecArray;
  };

  mv3 = function(mat, vec) {
    return [mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2], mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2], mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2]];
  };

  mm3 = function(A, B) {
    return [[A[0][0] * B[0][0] + A[0][1] * B[1][0] + A[0][2] * B[2][0], A[0][0] * B[0][1] + A[0][1] * B[1][1] + A[0][2] * B[2][1], A[0][0] * B[0][2] + A[0][1] * B[1][2] + A[0][2] * B[2][2]], [A[1][0] * B[0][0] + A[1][1] * B[1][0] + A[1][2] * B[2][0], A[1][0] * B[0][1] + A[1][1] * B[1][1] + A[1][2] * B[2][1], A[1][0] * B[0][2] + A[1][1] * B[1][2] + A[1][2] * B[2][2]], [A[2][0] * B[0][0] + A[2][1] * B[1][0] + A[2][2] * B[2][0], A[2][0] * B[0][1] + A[2][1] * B[1][1] + A[2][2] * B[2][1], A[2][0] * B[0][2] + A[2][1] * B[1][2] + A[2][2] * B[2][2]]];
  };

  eye3 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

  rotm = function(phi, theta, psi) {
    var xy_mat, xz_mat, yz_mat;

    xy_mat = [[cos(phi), -1.0 * sin(phi), 0.0], [sin(phi), cos(phi), 0.0], [0.0, 0.0, 1.0]];
    yz_mat = [[cos(theta), 0, -1.0 * sin(theta)], [0, 1, 0], [sin(theta), 0, cos(theta)]];
    xz_mat = [[1.0, 0, 0], [0, cos(psi), -1.0 * sin(psi)], [0, sin(psi), cos(psi)]];
    return mm3(xz_mat, mm3(yz_mat, xy_mat));
  };

  vec_rotm = function(angle, x, y, z) {
    var cosA, length, m, sinA, sinA2, x2, y2, z2, _ref, _ref1;

    angle /= 2;
    sinA = sin(angle);
    cosA = cos(angle);
    sinA2 = sinA * sinA;
    length = mag([x, y, z]);
    if (length === 0) {
      _ref = [0, 0, 1], x = _ref[0], y = _ref[1], z = _ref[2];
    }
    if (length !== 1) {
      _ref1 = unit([x, y, z]), x = _ref1[0], y = _ref1[1], z = _ref1[2];
    }
    if (x === 1 && y === 0 && z === 0) {
      m = [[1, 0, 0], [0, 1 - 2 * sinA2, 2 * sinA * cosA], [0, -2 * sinA * cosA, 1 - 2 * sinA2]];
    } else if (x === 0 && y === 1 && z === 0) {
      m = [[1 - 2 * sinA2, 0, -2 * sinA * cosA], [0, 1, 0], [2 * sinA * cosA, 0, 1 - 2 * sinA2]];
    } else if (x === 0 && y === 0 && z === 1) {
      m = [[1 - 2 * sinA2, 2 * sinA * cosA, 0], [-2 * sinA * cosA, 1 - 2 * sinA2, 0], [0, 0, 1]];
    } else {
      x2 = x * x;
      y2 = y * y;
      z2 = z * z;
      m = [[1 - 2 * (y2 + z2) * sinA2, 2 * (x * y * sinA2 + z * sinA * cosA), 2 * (x * z * sinA2 - y * sinA * cosA)], [2 * (y * x * sinA2 - z * sinA * cosA), 1 - 2 * (z2 + x2) * sinA2, 2 * (y * z * sinA2 + x * sinA * cosA)], [2 * (z * x * sinA2 + y * sinA * cosA), 2 * (z * y * sinA2 - x * sinA * cosA), 1 - 2 * (x2 + y2) * sinA2]];
    }
    return m;
  };

  perspT = function(vec3, max_real_depth, min_real_depth, desired_ratio, desired_length) {
    var scalefactor, z0;

    z0 = (max_real_depth * desired_ratio - min_real_depth) / (1 - desired_ratio);
    scalefactor = desired_length * desired_ratio / (1 - desired_ratio);
    return [scalefactor * vec3[0] / (vec3[2] + z0), scalefactor * vec3[1] / (vec3[2] + z0)];
  };

  invperspT = function(x, y, dx, dy, max_real_depth, min_real_depth, desired_ratio, desired_length) {
    var s, s2, xp, xp2, xsphere, yp, yp2, ysphere, z0, z02, zsphere;

    z0 = (max_real_depth * desired_ratio - min_real_depth) / (1 - desired_ratio);
    s = desired_length * desired_ratio / (1 - desired_ratio);
    xp = x - dx;
    yp = y - dy;
    s2 = s * s;
    z02 = z0 * z0;
    xp2 = xp * xp;
    yp2 = yp * yp;
    xsphere = (2 * s * xp * z0 + sqrt(4 * s2 * xp2 * z02 + 4 * xp2 * (s2 + xp2 + yp2) * (1 - z02))) / (2.0 * (s2 + xp2 + yp2));
    ysphere = (s * yp * z0) / (s2 + xp2 + yp2) + (yp * sqrt(4 * s2 * z02 + 4 * (s2 + xp2 + yp2) * (1 - z02))) / (2.0 * (s2 + xp2 + yp2));
    zsphere = sqrt(1 - xsphere * xsphere - ysphere * ysphere);
    return [xsphere, ysphere, zsphere];
  };

  getVec2VecRotM = function(vec1, vec2) {
    var angle, axis;

    axis = cross(vec1, vec2);
    angle = acos(dot(vec1, vec2));
    return vec_rotm(-1 * angle, axis[0], axis[1], axis[2]);
  };

  faceToEdges = function(face) {
    var edges, v1, v2, _i, _len;

    edges = [];
    v1 = face.slice(-1)[0];
    for (_i = 0, _len = face.length; _i < _len; _i++) {
      v2 = face[_i];
      edges.push([v1, v2]);
      v1 = v2;
    }
    return edges;
  };

  vertColors = function(poly) {
    var f, i, v, vertcolors, _i, _j, _len, _len1, _ref;

    vertcolors = [];
    _ref = poly.face;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      f = _ref[i];
      for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
        v = f[_j];
        vertcolors[v] = poly.face_class[i];
      }
    }
    return vertcolors;
  };

  rwb_palette = ["#ff7777", "#dddddd", "#889999", "#fff0e5", "#aa3333", "#ff0000", "#ffffff", "#aaaaaa"];

  hextofloats = function(hexstr) {
    var rgb;

    if (hexstr[0] === "#") {
      hexstr = hexstr.slice(1);
    }
    if (hexstr.length === 3) {
      rgb = hexstr.split('').map(function(c) {
        return parseInt(c + c, 16) / 255;
      });
    } else {
      rgb = hexstr.match(/.{2}/g).map(function(c) {
        return parseInt(c, 16) / 255;
      });
    }
    return rgb;
  };

  PALETTE = rwb_palette;

  palette = function(n) {
    if (n < PALETTE.length) {
      return hextofloats(PALETTE[n]);
    } else {
      return hextofloats(PALETTE[PALETTE.length - 1]);
    }
  };

  paintPolyhedron = function(poly) {
    var clr, colorassign, colormemory, f, face_verts, v, _i, _len, _ref;

    poly.face_class = [];
    colormemory = {};
    colorassign = function(ar, colormemory) {
      var fclr, hash;

      hash = round(100 * ar);
      if (hash in colormemory) {
        return colormemory[hash];
      } else {
        fclr = _.toArray(colormemory).length;
        colormemory[hash] = fclr;
        return fclr;
      }
    };
    _ref = poly.face;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      if (COLOR_METHOD === "area") {
        face_verts = (function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
            v = f[_j];
            _results.push(poly.xyz[v]);
          }
          return _results;
        })();
        clr = colorassign(convexarea(face_verts), colormemory);
      } else if (COLOR_METHOD === "signature") {
        face_verts = (function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
            v = f[_j];
            _results.push(poly.xyz[v]);
          }
          return _results;
        })();
        clr = colorassign(faceSignature(face_verts), colormemory);
      } else {
        clr = f.length - 3;
      }
      poly.face_class.push(clr);
    }
    console.log(_.toArray(colormemory).length + " face classes");
    return poly;
  };

  sortfaces = function(poly) {
    var centroids, extents, idx, normals, ray_origin, zcentroidsort, zmaxsort, zsortIndex, _i, _ref, _results;

    centroids = poly.centers();
    normals = poly.normals();
    extents = poly.extents();
    ray_origin = [0, 0, (persp_z_max * persp_ratio - persp_z_min) / (1 - persp_ratio)];
    zcentroidsort = function(a, b) {
      return a[1][2] - b[1][2];
    };
    zmaxsort = function(a, b) {
      return a[3][2][1] - b[3][2][1];
    };
    zsortIndex = _.zip((function() {
      _results = [];
      for (var _i = 0, _ref = poly.face.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), centroids, normals, extents).sort(zcentroidsort).map(function(x) {
      return x[0];
    });
    poly.face = (function() {
      var _j, _len, _results1;

      _results1 = [];
      for (_j = 0, _len = zsortIndex.length; _j < _len; _j++) {
        idx = zsortIndex[_j];
        _results1.push(poly.face[idx]);
      }
      return _results1;
    })();
    return poly.face_class = (function() {
      var _j, _len, _results1;

      _results1 = [];
      for (_j = 0, _len = zsortIndex.length; _j < _len; _j++) {
        idx = zsortIndex[_j];
        _results1.push(poly.face_class[idx]);
      }
      return _results1;
    })();
  };

  facesidedness = function(faceverts1, faceverts2, refpoint) {
    var c1, n1, oppsided, refside, samesided, sidedness, vert, _i, _len;

    n1 = normal(faceverts1);
    c1 = calcCentroid(faceverts1);
    refside = dot(sub(refpoint, c1), n1);
    samesided = true;
    oppsided = true;
    for (_i = 0, _len = faceverts2.length; _i < _len; _i++) {
      vert = faceverts2[_i];
      sidedness = dot(sub(vert, c1), n1) * refside;
      if (abs(sidedness) < 1e-10) {
        sidedness = 0;
      }
      if (sidedness < 0) {
        samesided = false;
      }
      if (sidedness > 0) {
        oppsided = false;
      }
    }
    if (samesided) {
      return 1;
    } else if (oppsided) {
      return -1;
    } else {
      return 0;
    }
  };

  sortfaces_fancy = function(poly) {
    var A_B_o, AmaxX, AmaxY, AmaxZ, AminX, AminY, AminZ, B_A_o, BmaxX, BmaxY, BmaxZ, BminX, BminY, BminZ, a, aidx, b, bidx, centroids, extents, extentsort, facenums, fno2, idx, ii, ray_origin, sortPtr, v, zminsort, zsortIndex, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _results;

    ray_origin = [0, 0, (persp_z_max * persp_ratio - persp_z_min) / (1 - persp_ratio)];
    centroids = poly.centers();
    extents = poly.extents();
    zminsort = function(a, b) {
      return a[1][2][0] - b[1][2][0];
    };
    extentsort = function(a, b) {
      var amax, amin, bmax, bmin, diff, _ref, _ref1;

      _ref = a[1][2], amin = _ref[0], amax = _ref[1];
      _ref1 = b[1][2], bmin = _ref1[0], bmax = _ref1[1];
      diff = amin - bmin;
      if (abs(diff) < 1e-10) {
        diff = 0;
      }
      if (diff !== 0) {
        return diff;
      }
      diff = amax - bmax;
      if (abs(diff) < 1e-10) {
        diff = 0;
      }
      return diff;
    };
    zsortIndex = _.zip((function() {
      _results = [];
      for (var _i = 0, _ref = poly.face.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), extents, centroids).sort(extentsort).map(function(x) {
      return x[0];
    });
    facenums = (function() {
      var _j, _len, _results1;

      _results1 = [];
      for (_j = 0, _len = zsortIndex.length; _j < _len; _j++) {
        idx = zsortIndex[_j];
        _results1.push(idx);
      }
      return _results1;
    })();
    sortPtr = 0;
    console.log(facenums);
    ii = 0;
    while (sortPtr < facenums.length - 1 && ii < 500) {
      ii += 1;
      aidx = facenums[sortPtr];
      for (fno2 = _j = 0, _len = facenums.length; _j < _len; fno2 = ++_j) {
        bidx = facenums[fno2];
        if (fno2 <= sortPtr) {
          continue;
        }
        a = (function() {
          var _k, _len1, _ref1, _results1;

          _ref1 = poly.face[aidx];
          _results1 = [];
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            v = _ref1[_k];
            _results1.push(poly.xyz[v]);
          }
          return _results1;
        })();
        b = (function() {
          var _k, _len1, _ref1, _results1;

          _ref1 = poly.face[bidx];
          _results1 = [];
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            v = _ref1[_k];
            _results1.push(poly.xyz[v]);
          }
          return _results1;
        })();
        _ref1 = calcExtents(a), (_ref2 = _ref1[0], AminX = _ref2[0], AmaxX = _ref2[1]), (_ref3 = _ref1[1], AminY = _ref3[0], AmaxY = _ref3[1]), (_ref4 = _ref1[2], AminZ = _ref4[0], AmaxZ = _ref4[1]);
        _ref5 = calcExtents(b), (_ref6 = _ref5[0], BminX = _ref6[0], BmaxX = _ref6[1]), (_ref7 = _ref5[1], BminY = _ref7[0], BmaxY = _ref7[1]), (_ref8 = _ref5[2], BminZ = _ref8[0], BmaxZ = _ref8[1]);
        if (BmaxZ < AminZ) {
          console.log("wtf pre-ordering fail", aidx, "=", AminZ, AmaxZ, " ", bidx, "=", BminZ, BmaxZ);
        }
        if (AmaxZ <= BminZ || BmaxZ <= AminZ) {
          continue;
        }
        if (AmaxX <= BminX || BmaxX <= AminX) {
          continue;
        }
        if (AmaxY <= BminY || BmaxY <= AminY) {
          continue;
        }
        A_B_o = facesidedness(a, b, ray_origin);
        B_A_o = facesidedness(b, a, ray_origin);
        if (A_B_o === 1 || B_A_o === -1) {
          continue;
        }
        if (B_A_o === 1 || A_B_o === -1) {
          facenums[sortPtr] = bidx;
          facenums[fno2] = aidx;
          console.log("switch", aidx, bidx, A_B_o, B_A_o);
          sortPtr = -1;
          break;
        }
        console.log("Warning: All tests failed on ", aidx, bidx);
        break;
      }
      sortPtr += 1;
    }
    console.log(sortPtr, ii);
    poly.face = (function() {
      var _k, _len1, _results1;

      _results1 = [];
      for (_k = 0, _len1 = facenums.length; _k < _len1; _k++) {
        idx = facenums[_k];
        _results1.push(poly.face[idx]);
      }
      return _results1;
    })();
    return poly.face_class = (function() {
      var _k, _len1, _results1;

      _results1 = [];
      for (_k = 0, _len1 = facenums.length; _k < _len1; _k++) {
        idx = facenums[_k];
        _results1.push(poly.face_class[idx]);
      }
      return _results1;
    })();
  };

  lineIsect2D = function(a, b, sameLineException) {
    var a1, a2, b1, b2, crossp, da, db, dt, du, pa2, pb1, pb2, _ref;

    if (sameLineException == null) {
      sameLineException = false;
    }
    a1 = a[0], a2 = a[1];
    b1 = b[0], b2 = b[1];
    da = sub2D(a2, a1);
    db = sub2D(b2, b1);
    crossp = cross2D(da, db);
    if (chop(crossp) === 0) {
      if (cross2D(sub2D(b1, a1), da) === 0) {
        pa2 = dot2D(da, da);
        pb1 = dot2D(sub2D(b1, a1), da);
        pb2 = dot2D(sub2D(b2, a1), da);
        if (pb1 > pb2) {
          _ref = [pb2, pb1], pb1 = _ref[0], pb2 = _ref[1];
        }
        if (sameLineException && pb1 === 0 && (pb2 = pa2)) {
          return false;
        }
        if (pb2 <= 0 || pb1 >= pa2) {
          return false;
        } else {
          return true;
        }
      } else {
        return false;
      }
    }
    du = chop(cross2D(sub2D(b1, a1), da) / crossp);
    dt = chop(cross2D(sub2D(b1, a1), db) / crossp);
    if ((0 < du && du < 1) && (0 < dt && dt < 1)) {
      return true;
    } else {
      return false;
    }
  };

  polygonIsectTest = function(a, b) {
    var Aedge, Aedges, Apt, Bedge, Bedges, Bpt, cnt, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n;

    Aedges = _.zip(a.slice(1), a.slice(0, +(a.length - 2) + 1 || 9e9));
    Aedges.push([a[a.length - 1], a[0]]);
    Bedges = _.zip(b.slice(1), b.slice(0, +(b.length - 2) + 1 || 9e9));
    Bedges.push([b[b.length - 1], b[0]]);
    for (_i = 0, _len = Aedges.length; _i < _len; _i++) {
      Aedge = Aedges[_i];
      for (_j = 0, _len1 = Bedges.length; _j < _len1; _j++) {
        Bedge = Bedges[_j];
        if (lineIsect2D(Aedge, Bedge, true)) {
          return true;
        }
      }
    }
    for (_k = 0, _len2 = a.length; _k < _len2; _k++) {
      Apt = a[_k];
      cnt = 0;
      for (_l = 0, _len3 = Bedges.length; _l < _len3; _l++) {
        Bedge = Bedges[_l];
        if (lineIsect2D(Bedge, [Apt, [10000, 0]])) {
          cnt += 1;
        }
      }
      if (cnt % 2 !== 0) {
        return true;
      }
    }
    for (_m = 0, _len4 = b.length; _m < _len4; _m++) {
      Bpt = b[_m];
      cnt = 0;
      for (_n = 0, _len5 = Aedges.length; _n < _len5; _n++) {
        Aedge = Aedges[_n];
        if (lineIsect2D(Aedge, [Bpt, [10000, 0]])) {
          cnt += 1;
        }
      }
      if (cnt % 2 !== 0) {
        return true;
      }
    }
    return false;
  };

  polygonclip = function(polyA, polyB) {
    var clip_polygon, clip_polygons, cpr, scale_factor, soln, solution_polygons, subj_polygon, subj_polygons, succeeded, x, xy, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

    scale_factor = 10000.0;
    subj_polygons = [];
    subj_polygon = [];
    for (_i = 0, _len = polyA.length; _i < _len; _i++) {
      _ref = polyA[_i], x = _ref[0], y = _ref[1];
      subj_polygon.push({
        'X': x * scale_factor,
        'Y': y * scale_factor
      });
    }
    subj_polygons.push(subj_polygon);
    clip_polygons = [];
    clip_polygon = [];
    for (_j = 0, _len1 = polyA.length; _j < _len1; _j++) {
      _ref1 = polyA[_j], x = _ref1[0], y = _ref1[1];
      clip_polygon.push({
        'X': x * scale_factor,
        'Y': y * scale_factor
      });
    }
    clip_polygons.push(clip_polygon);
    cpr = new ClipperLib.Clipper();
    cpr.AddPolygons(subj_polygons, ClipperLib.PolyType.ptSubject);
    cpr.AddPolygons(clip_polygons, ClipperLib.PolyType.ptClip);
    solution_polygons = new ClipperLib.Polygons();
    succeeded = cpr.Execute(0, solution_polygons, 1, 1);
    soln = [];
    _ref2 = solution_polygons[0];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      xy = _ref2[_k];
      soln.push([xy['X'] / scale_factor, xy['Y'] / scale_factor]);
    }
    return soln;
  };

  sortfaces_fancy2 = function(poly, persp_z_max, persp_z_min, persp_ratio, perspective_scale) {
    var centroids, extents, extentsort, f, facePts, idx, perspTfacePts, ray_origin, sortF, v, wtfs, zsortIndex, _i, _ref, _results;

    ray_origin = [0, 0, (persp_z_max * persp_ratio - persp_z_min) / (1 - persp_ratio)];
    centroids = poly.centers();
    extents = poly.extents();
    facePts = (function() {
      var _i, _len, _ref, _results;

      _ref = poly.face;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;

          _results1 = [];
          for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
            v = f[_j];
            _results1.push(poly.xyz[v]);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    perspTfacePts = (function() {
      var _i, _len, _ref, _results;

      _ref = poly.face;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;

          _results1 = [];
          for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
            v = f[_j];
            _results1.push(perspT(poly.xyz[v], persp_z_max, persp_z_min, persp_ratio, perspective_scale));
          }
          return _results1;
        })());
      }
      return _results;
    })();
    chop = function(x) {
      if (abs(x) < 1e-10) {
        return 0;
      } else {
        return x;
      }
    };
    extentsort = function(a, b) {
      var amax, amin, bmax, bmin, diff;

      amin = a[0], amax = a[1];
      bmin = b[0], bmax = b[1];
      diff = chop(amin - bmin);
      if (diff !== 0) {
        return diff;
      }
      diff = chop(amax - bmax);
      return diff;
    };
    zsortIndex = _.zip((function() {
      _results = [];
      for (var _i = 0, _ref = poly.face.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), extents, centroids).sort(function(a, b) {
      return extentsort(a[1][2], b[1][2]);
    }).map(function(x) {
      return x[0];
    });
    wtfs = [];
    sortF = function(aidx, bidx) {
      var A_B_o, AmaxX, AmaxY, AmaxZ, AminX, AminY, AminZ, B_A_o, BmaxX, BmaxY, BmaxZ, BminX, BminY, BminZ, a, b, pA, pB, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;

      a = facePts[aidx];
      b = facePts[bidx];
      _ref1 = calcPerspExtents(a, persp_z_max, persp_z_min, persp_ratio, perspective_scale), (_ref2 = _ref1[0], AminX = _ref2[0], AmaxX = _ref2[1]), (_ref3 = _ref1[1], AminY = _ref3[0], AmaxY = _ref3[1]), (_ref4 = _ref1[2], AminZ = _ref4[0], AmaxZ = _ref4[1]);
      _ref5 = calcPerspExtents(b, persp_z_max, persp_z_min, persp_ratio, perspective_scale), (_ref6 = _ref5[0], BminX = _ref6[0], BmaxX = _ref6[1]), (_ref7 = _ref5[1], BminY = _ref7[0], BmaxY = _ref7[1]), (_ref8 = _ref5[2], BminZ = _ref8[0], BmaxZ = _ref8[1]);
      if (chop(AmaxZ - BminZ) <= 0 || chop(BmaxZ - AminZ) <= 0) {
        return chop(AminZ - BminZ);
      }
      if (chop(AmaxX - BminX) <= 0 || chop(BmaxX - AminX) <= 0) {
        return chop(AminZ - BminZ);
      }
      if (chop(AmaxY - BminY) <= 0 || chop(BmaxY - AminY) <= 0) {
        return chop(AminZ - BminZ);
      }
      pA = perspTfacePts[aidx];
      pB = perspTfacePts[bidx];
      if (!polygonIsectTest(pA, pB)) {
        return chop(AminZ - BminZ);
      }
      A_B_o = facesidedness(a, b, ray_origin);
      B_A_o = facesidedness(b, a, ray_origin);
      if (A_B_o === 1 || B_A_o === -1) {
        console.log("noswitch", aidx, bidx, A_B_o, B_A_o);
        return -1;
      }
      if (B_A_o === 1 || A_B_o === -1) {
        console.log("switch", aidx, bidx, A_B_o, B_A_o);
        return 1;
      }
      if (wtfs.length === 0) {
        wtfs.push(poly.face[aidx]);
        wtfs.push(poly.face[bidx]);
        console.log("wtf", aidx, bidx, A_B_o, B_A_o);
        pA = perspTfacePts[aidx];
        pB = perspTfacePts[bidx];
        if (!polygonIsectTest(pA, pB)) {
          console.log("no isect", aidx, bidx);
        } else {
          console.log("isect", aidx, bidx);
        }
      }
      return chop(AminZ - BminZ);
    };
    zsortIndex.sort(sortF);
    poly.face = (function() {
      var _j, _len, _results1;

      _results1 = [];
      for (_j = 0, _len = zsortIndex.length; _j < _len; _j++) {
        idx = zsortIndex[_j];
        _results1.push(poly.face[idx]);
      }
      return _results1;
    })();
    poly.face_class = (function() {
      var _j, _len, _results1;

      _results1 = [];
      for (_j = 0, _len = zsortIndex.length; _j < _len; _j++) {
        idx = zsortIndex[_j];
        _results1.push(poly.face_class[idx]);
      }
      return _results1;
    })();
    return wtfs;
  };

  polyhedron = (function() {
    function polyhedron(verts, faces, name) {
      this.face = faces || new Array();
      this.xyz = verts || new Array();
      this.name = name || "null polyhedron";
    }

    polyhedron.prototype.data = function() {
      var nEdges;

      nEdges = this.face.length + this.xyz.length - 2;
      return "(" + this.face.length + " faces, " + nEdges + " edges, " + this.xyz.length + " vertices)";
    };

    polyhedron.prototype.edges = function() {
      var a, alledges, b, e, edgeset, finalset, hash, uniqedges, _i, _j, _len, _len1;

      finalset = {};
      uniqedges = [];
      alledges = _.map(this.face, faceToEdges);
      for (_i = 0, _len = alledges.length; _i < _len; _i++) {
        edgeset = alledges[_i];
        for (_j = 0, _len1 = edgeset.length; _j < _len1; _j++) {
          e = edgeset[_j];
          if (e[0] < e[1]) {
            a = e[0], b = e[1];
          } else {
            b = e[0], a = e[1];
          }
          finalset[a + '~' + b] = e;
        }
      }
      for (hash in finalset) {
        e = finalset[hash];
        uniqedges.push(e);
      }
      return uniqedges;
    };

    polyhedron.prototype.centers = function() {
      var centers_array, f, fcenter, v, _i, _j, _len, _len1, _ref;

      centers_array = [];
      _ref = this.face;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        fcenter = [0, 0, 0];
        for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
          v = f[_j];
          fcenter = add(fcenter, this.xyz[v]);
        }
        centers_array.push(mult(1.0 / f.length, fcenter));
      }
      return centers_array;
    };

    polyhedron.prototype.normals = function() {
      var f, normals_array, v, _i, _len, _ref;

      normals_array = [];
      _ref = this.face;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        normals_array.push(normal((function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
            v = f[_j];
            _results.push(this.xyz[v]);
          }
          return _results;
        }).call(this)));
      }
      return normals_array;
    };

    polyhedron.prototype.extents = function() {
      var extents_array, f, maxX, maxY, maxZ, minX, minY, minZ, v, x, y, z, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

      extents_array = [];
      _ref = this.face;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _ref1 = this.xyz[f[0]], x = _ref1[0], y = _ref1[1], z = _ref1[2];
        _ref2 = [x, x], maxX = _ref2[0], minX = _ref2[1];
        _ref3 = [y, y], maxY = _ref3[0], minY = _ref3[1];
        _ref4 = [z, z], maxZ = _ref4[0], minZ = _ref4[1];
        for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
          v = f[_j];
          _ref5 = this.xyz[v], x = _ref5[0], y = _ref5[1], z = _ref5[2];
          maxX = maxX < x ? x : maxX;
          minX = minX > x ? x : minX;
          maxY = maxY < y ? y : maxY;
          minY = minY > y ? y : minY;
          maxZ = maxZ < z ? z : maxZ;
          minZ = minZ > z ? z : minZ;
        }
        extents_array.push([[minX, maxX], [minY, maxY], [minZ, maxZ]]);
      }
      return extents_array;
    };

    polyhedron.prototype.toOBJ = function() {
      var f, i, norm, objstr, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;

      objstr = "#Produced by polyHédronisme http://levskaya.github.com/polyhedronisme\n";
      objstr += "group " + this.name + "\n";
      objstr += "#vertices\n";
      _ref = this.xyz;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        objstr += "v " + v[0] + " " + v[1] + " " + v[2] + "\n";
      }
      objstr += "#normal vector defs \n";
      _ref1 = this.face;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        f = _ref1[_j];
        norm = normal((function() {
          var _k, _len2, _results;

          _results = [];
          for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
            v = f[_k];
            _results.push(this.xyz[v]);
          }
          return _results;
        }).call(this));
        objstr += "vn " + norm[0] + " " + norm[1] + " " + norm[2] + "\n";
      }
      objstr += "#face defs \n";
      _ref2 = this.face;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        f = _ref2[i];
        objstr += "f ";
        for (_l = 0, _len3 = f.length; _l < _len3; _l++) {
          v = f[_l];
          objstr += "" + (v + 1) + "//" + (i + 1) + " ";
        }
        objstr += "\n";
      }
      return objstr;
    };

    polyhedron.prototype.toX3D = function() {
      var SCALE_FACTOR, cl, clr, f, v, x3dstr, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;

      SCALE_FACTOR = .01;
      x3dstr = '<?xml version="1.0" encoding ="UTF-8"?>\n<X3D profile="Interchange" version="3.0">\n<head>\n<component name="Rendering" level="3"/>\n<meta name="generator" content="Polyhedronisme"/>\n<meta name="version" content="0.1.0"/>\n</head>\n<Scene>\n<Shape>\n<IndexedFaceSet normalPerVertex="false" coordIndex="';
      _ref = this.face;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
          v = f[_j];
          x3dstr += "" + v + " ";
        }
        x3dstr += '-1\n';
      }
      x3dstr += '">\n';
      x3dstr += '<Color color="';
      _ref1 = vertColors(this);
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        cl = _ref1[_k];
        clr = palette(cl);
        x3dstr += "" + clr[0] + " " + clr[1] + " " + clr[2] + " ";
      }
      x3dstr += '"/>';
      x3dstr += '<Coordinate point="';
      _ref2 = this.xyz;
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        v = _ref2[_l];
        x3dstr += "" + (v[0] * SCALE_FACTOR) + " " + (v[1] * SCALE_FACTOR) + " " + (v[2] * SCALE_FACTOR) + " ";
      }
      x3dstr += '"/>\n';
      x3dstr += '</IndexedFaceSet>\n</Shape>\n</Scene>\n</X3D>';
      return x3dstr;
    };

    polyhedron.prototype.toVRML = function() {
      var SCALE_FACTOR, cl, clr, f, v, x3dstr, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;

      SCALE_FACTOR = .01;
      x3dstr = '#VRML V2.0 utf8\n#Generated by Polyhedronisme\nNavigationInfo {\n	type [ "EXAMINE", "ANY" ]\n}\nTransform {\n  scale 1 1 1\n  translation 0 0 0\n  children\n  [\n    Shape\n    {\n      geometry IndexedFaceSet\n      {\n        creaseAngle .5\n        solid FALSE\n        coord Coordinate\n        {\n          point\n          [';
      _ref = this.xyz;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        x3dstr += "" + (v[0] * SCALE_FACTOR) + " " + (v[1] * SCALE_FACTOR) + " " + (v[2] * SCALE_FACTOR) + ",";
      }
      x3dstr = x3dstr.slice(0, -1);
      x3dstr += '    ]\n}\ncolor Color\n{\n  color\n  [';
      _ref1 = this.face_class;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        cl = _ref1[_j];
        clr = palette(cl);
        x3dstr += "" + clr[0] + " " + clr[1] + " " + clr[2] + " ,";
      }
      x3dstr = x3dstr.slice(0, -1);
      x3dstr += '  ]\n}\ncolorPerVertex FALSE\ncoordIndex\n[';
      _ref2 = this.face;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        f = _ref2[_k];
        for (_l = 0, _len3 = f.length; _l < _len3; _l++) {
          v = f[_l];
          x3dstr += "" + v + ", ";
        }
        x3dstr += '-1,';
      }
      x3dstr = x3dstr.slice(0, -1);
      x3dstr += '          ]\n      }\n      appearance Appearance\n      {\n        material Material\n        {\n	       ambientIntensity 0.2\n	       diffuseColor 0.9 0.9 0.9\n	       specularColor .1 .1 .1\n	       shininess .5\n        }\n      }\n    }\n  ]\n}';
      return x3dstr;
    };

    return polyhedron;

  })();

  tetrahedron = function() {
    var poly;

    poly = new polyhedron();
    poly.name = "T";
    poly.face = [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]];
    poly.xyz = [[1.0, 1.0, 1.0], [1.0, -1.0, -1.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, 1.0]];
    return poly;
  };

  octahedron = function() {
    var poly;

    poly = new polyhedron();
    poly.name = "O";
    poly.face = [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]];
    poly.xyz = [[0, 0, 1.414], [1.414, 0, 0], [0, 1.414, 0], [-1.414, 0, 0], [0, -1.414, 0], [0, 0, -1.414]];
    return poly;
  };

  cube = function() {
    var poly;

    poly = new polyhedron();
    poly.name = "C";
    poly.face = [[3, 0, 1, 2], [3, 4, 5, 0], [0, 5, 6, 1], [1, 6, 7, 2], [2, 7, 4, 3], [5, 4, 7, 6]];
    poly.xyz = [[0.707, 0.707, 0.707], [-0.707, 0.707, 0.707], [-0.707, -0.707, 0.707], [0.707, -0.707, 0.707], [0.707, -0.707, -0.707], [0.707, 0.707, -0.707], [-0.707, 0.707, -0.707], [-0.707, -0.707, -0.707]];
    return poly;
  };

  icosahedron = function() {
    var poly;

    poly = new polyhedron();
    poly.name = "I";
    poly.face = [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]];
    poly.xyz = [[0, 0, 1.176], [1.051, 0, 0.526], [0.324, 1.0, 0.525], [-0.851, 0.618, 0.526], [-0.851, -0.618, 0.526], [0.325, -1.0, 0.526], [0.851, 0.618, -0.526], [0.851, -0.618, -0.526], [-0.325, 1.0, -0.526], [-1.051, 0, -0.526], [-0.325, -1.0, -0.526], [0, 0, -1.176]];
    return poly;
  };

  dodecahedron = function() {
    var poly;

    poly = new polyhedron();
    poly.name = "D";
    poly.face = [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]];
    poly.xyz = [[0, 0, 1.07047], [0.713644, 0, 0.797878], [-0.356822, 0.618, 0.797878], [-0.356822, -0.618, 0.797878], [0.797878, 0.618034, 0.356822], [0.797878, -0.618, 0.356822], [-0.934172, 0.381966, 0.356822], [0.136294, 1.0, 0.356822], [0.136294, -1.0, 0.356822], [-0.934172, -0.381966, 0.356822], [0.934172, 0.381966, -0.356822], [0.934172, -0.381966, -0.356822], [-0.797878, 0.618, -0.356822], [-0.136294, 1.0, -0.356822], [-0.136294, -1.0, -0.356822], [-0.797878, -0.618034, -0.356822], [0.356822, 0.618, -0.797878], [0.356822, -0.618, -0.797878], [-0.713644, 0, -0.797878], [0, 0, -1.07047]];
    return poly;
  };

  prism = function(n) {
    var h, i, poly, theta, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;

    theta = 2 * PI / n;
    h = Math.sin(theta / 2);
    poly = new polyhedron();
    poly.name = "P" + n;
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      poly.xyz.push([-cos(i * theta), -sin(i * theta), -h]);
    }
    for (i = _j = 0, _ref1 = n - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      poly.xyz.push([-cos(i * theta), -sin(i * theta), h]);
    }
    poly.face.push((function() {
      _results = [];
      for (var _k = _ref2 = n - 1; _ref2 <= 0 ? _k <= 0 : _k >= 0; _ref2 <= 0 ? _k++ : _k--){ _results.push(_k); }
      return _results;
    }).apply(this));
    poly.face.push((function() {
      _results1 = [];
      for (var _l = n, _ref3 = 2 * n - 1; n <= _ref3 ? _l <= _ref3 : _l >= _ref3; n <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
      return _results1;
    }).apply(this));
    for (i = _m = 0, _ref4 = n - 1; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
      poly.face.push([i, (i + 1) % n, (i + 1) % n + n, i + n]);
    }
    poly = adjustXYZ(poly, 1);
    return poly;
  };

  antiprism = function(n) {
    var f, h, i, poly, r, theta, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;

    theta = 2 * PI / n;
    h = sqrt(1 - 4 / (4 + 2 * cos(theta / 2) - 2 * cos(theta)));
    r = sqrt(1 - h * h);
    f = sqrt(h * h + pow(r * cos(theta / 2), 2));
    r = -r / f;
    h = -h / f;
    poly = new polyhedron();
    poly.name = "A" + n;
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      poly.xyz.push([r * cos(i * theta), r * sin(i * theta), h]);
    }
    for (i = _j = 0, _ref1 = n - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      poly.xyz.push([r * cos((i + 0.5) * theta), r * sin((i + 0.5) * theta), -h]);
    }
    poly.face.push((function() {
      _results = [];
      for (var _k = _ref2 = n - 1; _ref2 <= 0 ? _k <= 0 : _k >= 0; _ref2 <= 0 ? _k++ : _k--){ _results.push(_k); }
      return _results;
    }).apply(this));
    poly.face.push((function() {
      _results1 = [];
      for (var _l = n, _ref3 = 2 * n - 1; n <= _ref3 ? _l <= _ref3 : _l >= _ref3; n <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
      return _results1;
    }).apply(this));
    for (i = _m = 0, _ref4 = n - 1; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
      poly.face.push([i, (i + 1) % n, i + n]);
      poly.face.push([i, i + n, (n + i - 1) % n + n]);
    }
    poly = adjustXYZ(poly, 1);
    return poly;
  };

  pyramid = function(n) {
    var height, i, poly, theta, _i, _j, _k, _ref, _ref1, _ref2, _results;

    theta = 2 * PI / n;
    height = 1;
    poly = new polyhedron();
    poly.name = "Y" + n;
    for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      poly.xyz.push([-cos(i * theta), -sin(i * theta), -0.2]);
    }
    poly.xyz.push([0, 0, height]);
    poly.face.push((function() {
      _results = [];
      for (var _j = _ref1 = n - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this));
    for (i = _k = 0, _ref2 = n - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      poly.face.push([i, (i + 1) % n, n]);
    }
    poly = canonicalXYZ(poly, 3);
    return poly;
  };

  polyflag = (function() {
    function polyflag() {
      this.flags = new Object();
      this.verts = new Object();
      this.xyzs = new Object();
    }

    polyflag.prototype.newV = function(name, xyz) {
      if (this.verts[name] === void 0) {
        this.verts[name] = 0;
        return this.xyzs[name] = xyz;
      }
    };

    polyflag.prototype.newFlag = function(face, v1, v2) {
      if (this.flags[face] === void 0) {
        this.flags[face] = {};
      }
      return this.flags[face][v1] = v2;
    };

    polyflag.prototype.topoly = function() {
      var ctr, f, faceCTR, i, j, poly, v, v0, _ref, _ref1;

      poly = new polyhedron();
      ctr = 0;
      _ref = this.verts;
      for (i in _ref) {
        v = _ref[i];
        poly.xyz[ctr] = this.xyzs[i];
        this.verts[i] = ctr;
        ctr++;
      }
      ctr = 0;
      _ref1 = this.flags;
      for (i in _ref1) {
        f = _ref1[i];
        poly.face[ctr] = [];
        for (j in f) {
          v = f[j];
          v0 = v;
          break;
        }
        v = v0;
        poly.face[ctr].push(this.verts[v]);
        v = this.flags[i][v];
        faceCTR = 0;
        while (v !== v0) {
          poly.face[ctr].push(this.verts[v]);
          v = this.flags[i][v];
          faceCTR++;
          if (faceCTR > 1000) {
            console.log("Bad flag spec, have a neverending face:", i, this.flags[i]);
            break;
          }
        }
        ctr++;
      }
      poly.name = "unknown polyhedron";
      return poly;
    };

    return polyflag;

  })();

  kisN = function(poly, n, apexdist) {
    var apex, centers, f, flag, fname, foundAny, i, newpoly, normals, p, v, v1, v2, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

    n || (n = 0);
    apexdist || (apexdist = 0.1);
    console.log("Taking kis of " + (n === 0 ? "" : n) + "-sided faces of " + poly.name + "...");
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      flag.newV("v" + i, p);
    }
    normals = poly.normals();
    centers = poly.centers();
    foundAny = false;
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      v1 = "v" + f[f.length - 1];
      for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
        v = f[_k];
        v2 = "v" + v;
        if (f.length === n || n === 0) {
          foundAny = true;
          apex = "apex" + i;
          fname = "" + i + v1;
          flag.newV(apex, add(centers[i], mult(apexdist, normals[i])));
          flag.newFlag(fname, v1, v2);
          flag.newFlag(fname, v2, apex);
          flag.newFlag(fname, apex, v1);
        } else {
          flag.newFlag("" + i, v1, v2);
        }
        v1 = v2;
      }
    }
    if (!foundAny) {
      console.log("No " + n + "-fold components were found.");
    }
    newpoly = flag.topoly();
    newpoly.name = "k" + (n === 0 ? "" : n) + poly.name;
    return newpoly;
  };

  ambo = function(poly) {
    var f, flag, i, midName, newpoly, v1, v2, v3, _i, _j, _len, _len1, _ref, _ref1, _ref2;

    console.log("Taking ambo of " + poly.name + "...");
    midName = function(v1, v2) {
      if (v1 < v2) {
        return v1 + "_" + v2;
      } else {
        return v2 + "_" + v1;
      }
    };
    flag = new polyflag();
    _ref = poly.face;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      f = _ref[i];
      _ref1 = f.slice(-2), v1 = _ref1[0], v2 = _ref1[1];
      for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
        v3 = f[_j];
        if (v1 < v2) {
          flag.newV(midName(v1, v2), midpoint(poly.xyz[v1], poly.xyz[v2]));
        }
        flag.newFlag("orig" + i, midName(v1, v2), midName(v2, v3));
        flag.newFlag("dual" + v2, midName(v2, v3), midName(v1, v2));
        _ref2 = [v2, v3], v1 = _ref2[0], v2 = _ref2[1];
      }
    }
    newpoly = flag.topoly();
    newpoly.name = "a" + poly.name;
    return newpoly;
  };

  gyro = function(poly) {
    var centers, f, flag, fname, i, j, newpoly, v, v1, v2, v3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;

    console.log("Taking gyro of " + poly.name + "...");
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      v = _ref[i];
      flag.newV("v" + i, unit(v));
    }
    centers = poly.centers();
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      flag.newV("center" + i, unit(centers[i]));
    }
    _ref2 = poly.face;
    for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
      f = _ref2[i];
      _ref3 = f.slice(-2), v1 = _ref3[0], v2 = _ref3[1];
      for (j = _l = 0, _len3 = f.length; _l < _len3; j = ++_l) {
        v = f[j];
        v3 = v;
        flag.newV(v1 + "~" + v2, oneThird(poly.xyz[v1], poly.xyz[v2]));
        fname = i + "f" + v1;
        flag.newFlag(fname, "center" + i, v1 + "~" + v2);
        flag.newFlag(fname, v1 + "~" + v2, v2 + "~" + v1);
        flag.newFlag(fname, v2 + "~" + v1, "v" + v2);
        flag.newFlag(fname, "v" + v2, v2 + "~" + v3);
        flag.newFlag(fname, v2 + "~" + v3, "center" + i);
        _ref4 = [v2, v3], v1 = _ref4[0], v2 = _ref4[1];
      }
    }
    newpoly = flag.topoly();
    newpoly.name = "g" + poly.name;
    return newpoly;
  };

  propellor = function(poly) {
    var f, flag, fname, i, newpoly, v, v1, v2, v3, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;

    console.log("Taking propellor of " + poly.name + "...");
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      v = _ref[i];
      flag.newV("v" + i, unit(v));
    }
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      _ref2 = f.slice(-2), v1 = _ref2[0], v2 = _ref2[1];
      for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
        v = f[_k];
        v3 = "" + v;
        flag.newV(v1 + "~" + v2, oneThird(poly.xyz[v1], poly.xyz[v2]));
        fname = "" + i + "f" + v2;
        flag.newFlag("v" + i, v1 + "~" + v2, v2 + "~" + v3);
        flag.newFlag(fname, v1 + "~" + v2, v2 + "~" + v1);
        flag.newFlag(fname, v2 + "~" + v1, "v" + v2);
        flag.newFlag(fname, "v" + v2, v2 + "~" + v3);
        flag.newFlag(fname, v2 + "~" + v3, v1 + "~" + v2);
        _ref3 = [v2, v3], v1 = _ref3[0], v2 = _ref3[1];
      }
    }
    newpoly = flag.topoly();
    newpoly.name = "p" + poly.name;
    return newpoly;
  };

  reflect = function(poly) {
    var i, _i, _j, _ref, _ref1;

    console.log("Taking reflection of " + poly.name + "...");
    for (i = _i = 0, _ref = poly.xyz.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      poly.xyz[i] = mult(-1, poly.xyz[i]);
    }
    for (i = _j = 0, _ref1 = poly.face.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      poly.face[i] = poly.face[i].reverse();
    }
    poly.name = "r" + poly.name;
    return poly;
  };

  dual = function(poly) {
    var centers, dpoly, f, face, flag, i, k, sortF, v1, v2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;

    console.log("Taking dual of " + poly.name + "...");
    flag = new polyflag();
    face = [];
    for (i = _i = 0, _ref = poly.xyz.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      face[i] = {};
    }
    _ref1 = poly.face;
    for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
      f = _ref1[i];
      v1 = f[f.length - 1];
      for (_k = 0, _len1 = f.length; _k < _len1; _k++) {
        v2 = f[_k];
        face[v1]["v" + v2] = "" + i;
        v1 = v2;
      }
    }
    centers = poly.centers();
    for (i = _l = 0, _ref2 = poly.face.length - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
      flag.newV("" + i, centers[i]);
    }
    _ref3 = poly.face;
    for (i = _m = 0, _len2 = _ref3.length; _m < _len2; i = ++_m) {
      f = _ref3[i];
      v1 = f[f.length - 1];
      for (_n = 0, _len3 = f.length; _n < _len3; _n++) {
        v2 = f[_n];
        flag.newFlag(v1, face[v2]["v" + v1], "" + i);
        v1 = v2;
      }
    }
    dpoly = flag.topoly();
    sortF = [];
    _ref4 = dpoly.face;
    for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
      f = _ref4[_o];
      k = intersect(poly.face[f[0]], poly.face[f[1]], poly.face[f[2]]);
      sortF[k] = f;
    }
    dpoly.face = sortF;
    if (poly.name[0] !== "d") {
      dpoly.name = "d" + poly.name;
    } else {
      dpoly.name = poly.name.slice(1);
    }
    return dpoly;
  };

  insetN = function(poly, n, inset_dist, popout_dist) {
    var centers, f, flag, fname, foundAny, i, newpoly, normals, p, v, v1, v2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;

    n || (n = 0);
    inset_dist || (inset_dist = 0.5);
    popout_dist || (popout_dist = -0.2);
    console.log("Taking inset of " + (n === 0 ? "" : n) + "-sided faces of " + poly.name + "...");
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      flag.newV("v" + i, p);
    }
    normals = poly.normals();
    centers = poly.centers();
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      if (f.length === n || n === 0) {
        for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
          v = f[_k];
          flag.newV("f" + i + "v" + v, add(tween(poly.xyz[v], centers[i], inset_dist), mult(popout_dist, normals[i])));
        }
      }
    }
    foundAny = false;
    _ref2 = poly.face;
    for (i = _l = 0, _len3 = _ref2.length; _l < _len3; i = ++_l) {
      f = _ref2[i];
      v1 = "v" + f[f.length - 1];
      for (_m = 0, _len4 = f.length; _m < _len4; _m++) {
        v = f[_m];
        v2 = "v" + v;
        if (f.length === n || n === 0) {
          foundAny = true;
          fname = i + v1;
          flag.newFlag(fname, v1, v2);
          flag.newFlag(fname, v2, "f" + i + v2);
          flag.newFlag(fname, "f" + i + v2, "f" + i + v1);
          flag.newFlag(fname, "f" + i + v1, v1);
          flag.newFlag("ex" + i, "f" + i + v1, "f" + i + v2);
        } else {
          flag.newFlag(i, v1, v2);
        }
        v1 = v2;
      }
    }
    if (!foundAny) {
      console.log("No " + n + "-fold components were found.");
    }
    newpoly = flag.topoly();
    newpoly.name = "n" + (n === 0 ? "" : n) + poly.name;
    return newpoly;
  };

  hollow = function(poly, n, inset_dist, thickness) {
    var centers, dualnormals, f, flag, fname, foundAny, i, newpoly, normals, p, v, v1, v2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;

    n || (n = 0);
    inset_dist || (inset_dist = 0.5);
    thickness || (thickness = 0.2);
    console.log("Skeletonizing " + (n === 0 ? "" : n) + "-sided faces of " + poly.name + "...");
    dualnormals = dual(poly).normals();
    normals = poly.normals();
    centers = poly.centers();
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      flag.newV("v" + i, p);
      flag.newV("downv" + i, add(p, mult(-1 * thickness, dualnormals[i])));
    }
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
        v = f[_k];
        flag.newV("fin" + i + "v" + v, tween(poly.xyz[v], centers[i], inset_dist));
      }
    }
    _ref2 = poly.face;
    for (i = _l = 0, _len3 = _ref2.length; _l < _len3; i = ++_l) {
      f = _ref2[i];
      v1 = "v" + f[f.length - 1];
      for (_m = 0, _len4 = f.length; _m < _len4; _m++) {
        v = f[_m];
        v2 = "v" + v;
        foundAny = true;
        fname = i + v1;
        flag.newFlag(fname, v1, v2);
        flag.newFlag(fname, v2, "fin" + i + v2);
        flag.newFlag(fname, "fin" + i + v2, "fin" + i + v1);
        flag.newFlag(fname, "fin" + i + v1, v1);
        fname = "sides" + i + v1;
        flag.newFlag(fname, "down" + v2, "down" + v1);
        flag.newFlag(fname, "down" + v1, "fin" + i + v1);
        flag.newFlag(fname, "fin" + i + v1, "fin" + i + v2);
        flag.newFlag(fname, "fin" + i + v2, "down" + v2);
        v1 = v2;
      }
    }
    newpoly = flag.topoly();
    newpoly.name = "h" + poly.name;
    return newpoly;
  };

  extrudeN = function(poly, n) {
    var centers, f, flag, foundAny, i, newpoly, normals, p, v, v1, v2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;

    n || (n = 0);
    console.log("Taking extrusion of " + (n === 0 ? "" : n) + "-sided faces of " + poly.name + "...");
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      flag.newV("v" + i, p);
    }
    normals = poly.normals();
    centers = poly.centers();
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      if (f.length === n || n === 0) {
        for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
          v = f[_k];
          flag.newV("f" + i + "v" + v, add(poly.xyz[v], mult(0.3, normals[i])));
        }
      }
    }
    foundAny = false;
    _ref2 = poly.face;
    for (i = _l = 0, _len3 = _ref2.length; _l < _len3; i = ++_l) {
      f = _ref2[i];
      v1 = "v" + f[f.length - 1];
      for (_m = 0, _len4 = f.length; _m < _len4; _m++) {
        v = f[_m];
        v2 = "v" + v;
        if (f.length === n || n === 0) {
          foundAny = true;
          flag.newFlag(i + v1, v1, v2);
          flag.newFlag(i + v1, v2, "f" + i + v2);
          flag.newFlag(i + v1, "f" + i + v2, "f" + i + v1);
          flag.newFlag(i + v1, "f" + i + v1, v1);
          flag.newFlag("ex" + i, "f" + i + v1, "f" + i + v2);
        } else {
          flag.newFlag(i, v1, v2);
        }
        v1 = v2;
      }
    }
    if (!foundAny) {
      console.log("No " + n + "-fold components were found.");
    }
    newpoly = flag.topoly();
    newpoly.name = "x" + (n === 0 ? "" : n) + poly.name;
    return newpoly;
  };

  stellaN = function(poly) {
    var centers, f, flag, i, newpoly, p, v, v1, v12, v2, v21, v23, v3, vert1, vert2, vert3, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;

    console.log("Taking stella of " + poly.name + "...");
    centers = poly.centers();
    flag = new polyflag();
    _ref = poly.xyz;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      flag.newV("v" + i, p);
    }
    _ref1 = poly.face;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      f = _ref1[i];
      v1 = "v" + f[f.length - 2];
      v2 = "v" + f[f.length - 1];
      vert1 = poly.xyz[f[f.length - 2]];
      vert2 = poly.xyz[f[f.length - 1]];
      for (_k = 0, _len2 = f.length; _k < _len2; _k++) {
        v = f[_k];
        v3 = "v" + v;
        vert3 = poly.xyz[v];
        v12 = v1 + "~" + v2;
        v21 = v2 + "~" + v1;
        v23 = v2 + "~" + v3;
        flag.newV(v12, midpoint(midpoint(vert1, vert2), centers[i]));
        flag.newFlag("in" + i, v12, v23);
        flag.newFlag("f" + i + v2, v23, v12);
        flag.newFlag("f" + i + v2, v12, v2);
        flag.newFlag("f" + i + v2, v2, v23);
        flag.newFlag("f" + v12, v1, v21);
        flag.newFlag("f" + v12, v21, v12);
        flag.newFlag("f" + v12, v12, v1);
        _ref2 = [v2, v3], v1 = _ref2[0], v2 = _ref2[1];
        _ref3 = [vert2, vert3], vert1 = _ref3[0], vert2 = _ref3[1];
      }
    }
    newpoly = flag.topoly();
    newpoly.name = "l" + poly.name;
    return newpoly;
  };

  tangentify = function(xyzs, edges) {
    var STABILITY_FACTOR, c, e, newVs, t, _i, _len;

    STABILITY_FACTOR = 0.1;
    newVs = copyVecArray(xyzs);
    for (_i = 0, _len = edges.length; _i < _len; _i++) {
      e = edges[_i];
      t = tangentPoint(newVs[e[0]], newVs[e[1]]);
      c = mult(STABILITY_FACTOR * 1 / 2 * (1 - sqrt(dot(t, t))), t);
      newVs[e[0]] = add(newVs[e[0]], c);
      newVs[e[1]] = add(newVs[e[1]], c);
    }
    return newVs;
  };

  recenter = function(xyzs, edges) {
    var a, b, edgecenters, polycenter, v, _i, _len;

    edgecenters = (function() {
      var _i, _len, _ref, _results;

      _results = [];
      for (_i = 0, _len = edges.length; _i < _len; _i++) {
        _ref = edges[_i], a = _ref[0], b = _ref[1];
        _results.push(tangentPoint(xyzs[a], xyzs[b]));
      }
      return _results;
    })();
    polycenter = [0, 0, 0];
    for (_i = 0, _len = edgecenters.length; _i < _len; _i++) {
      v = edgecenters[_i];
      polycenter = add(polycenter, v);
    }
    polycenter = mult(1 / edges.length, polycenter);
    return _.map(xyzs, function(x) {
      return sub(x, polycenter);
    });
  };

  rescale = function(xyzs) {
    var maxExtent, polycenter, s;

    polycenter = [0, 0, 0];
    maxExtent = _.max(_.map(xyzs, function(x) {
      return mag(x);
    }));
    s = 1 / maxExtent;
    return _.map(xyzs, function(x) {
      return [s * x[0], s * x[1], s * x[2]];
    });
  };

  planarize = function(xyzs, faces) {
    var STABILITY_FACTOR, c, coords, f, n, newVs, v, _i, _j, _len, _len1;

    STABILITY_FACTOR = 0.1;
    newVs = copyVecArray(xyzs);
    for (_i = 0, _len = faces.length; _i < _len; _i++) {
      f = faces[_i];
      coords = (function() {
        var _j, _len1, _results;

        _results = [];
        for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
          v = f[_j];
          _results.push(xyzs[v]);
        }
        return _results;
      })();
      n = normal(coords);
      c = calcCentroid(coords);
      if (dot(n, c) < 0) {
        n = mult(-1.0, n);
      }
      for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
        v = f[_j];
        newVs[v] = add(newVs[v], mult(dot(mult(STABILITY_FACTOR, n), sub(c, xyzs[v])), n));
      }
    }
    return newVs;
  };

  canonicalize = function(poly, Niter) {
    var edges, faces, i, maxChange, newVs, newpoly, oldVs, _i;

    Niter || (Niter = 1);
    console.log("Canonicalizing " + poly.name + "...");
    faces = poly.face;
    edges = poly.edges();
    newVs = poly.xyz;
    maxChange = 1.0;
    for (i = _i = 0; 0 <= Niter ? _i <= Niter : _i >= Niter; i = 0 <= Niter ? ++_i : --_i) {
      oldVs = copyVecArray(newVs);
      newVs = tangentify(newVs, edges);
      newVs = recenter(newVs, edges);
      newVs = planarize(newVs, faces);
      maxChange = _.max(_.map(_.zip(newVs, oldVs), function(_arg) {
        var x, y;

        x = _arg[0], y = _arg[1];
        return mag(sub(x, y));
      }));
      if (maxChange < 1e-8) {
        break;
      }
    }
    console.log("[canonicalization done, last |deltaV|=" + maxChange + "]");
    newpoly = new polyhedron(newVs, poly.face, poly.name);
    console.log("canonicalize", newpoly);
    return newpoly;
  };

  reciprocalC = function(poly) {
    var c, centers, _i, _len;

    centers = poly.centers();
    for (_i = 0, _len = centers.length; _i < _len; _i++) {
      c = centers[_i];
      c = mult(1.0 / dot(c, c), c);
    }
    return centers;
  };

  reciprocalN = function(poly) {
    var ans, avgEdgeDist, centroid, f, normalV, tmp, v1, v2, v3, _i, _j, _len, _len1, _ref, _ref1, _ref2;

    ans = [];
    _ref = poly.face;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      centroid = [0, 0, 0];
      normalV = [0, 0, 0];
      avgEdgeDist = 0.0;
      _ref1 = f.slice(-2), v1 = _ref1[0], v2 = _ref1[1];
      for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
        v3 = f[_j];
        centroid = add(centroid, poly.xyz[v3]);
        normalV = add(normalV, orthogonal(poly.xyz[v1], poly.xyz[v2], poly.xyz[v3]));
        avgEdgeDist += edgeDist(poly.xyz[v1], poly.xyz[v2]);
        _ref2 = [v2, v3], v1 = _ref2[0], v2 = _ref2[1];
      }
      centroid = mult(1.0 / f.length, centroid);
      normalV = unit(normalV);
      avgEdgeDist = avgEdgeDist / f.length;
      tmp = reciprocal(mult(dot(centroid, normalV), normalV));
      ans.push(mult((1 + avgEdgeDist) / 2, tmp));
    }
    return ans;
  };

  canonicalXYZ = function(poly, nIterations) {
    var count, dpoly, _i, _ref;

    nIterations || (nIterations = 1);
    dpoly = dual(poly);
    console.log("Pseudo-canonicalizing " + poly.name + "...");
    for (count = _i = 0, _ref = nIterations - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; count = 0 <= _ref ? ++_i : --_i) {
      dpoly.xyz = reciprocalN(poly);
      poly.xyz = reciprocalN(dpoly);
    }
    return new polyhedron(poly.xyz, poly.face, poly.name);
  };

  adjustXYZ = function(poly, nIterations) {
    var count, dpoly, _i, _ref;

    nIterations || (nIterations = 1);
    dpoly = dual(poly);
    console.log("Planarizing " + poly.name + "...");
    for (count = _i = 0, _ref = nIterations - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; count = 0 <= _ref ? ++_i : --_i) {
      dpoly.xyz = reciprocalC(poly);
      poly.xyz = reciprocalC(dpoly);
    }
    return new polyhedron(poly.xyz, poly.face, poly.name);
  };

  getDiagonals = function(verts) {
    var Area2, Between, Collinear, Diagonal, Diagonalie, InCone, Intersect, IntersectProp, Left, LeftOn, XOR, broke, diagonals, ear, facelen, head, limiter, n, origIdx, v0, v1, v2, v3, v4, y, z, _i, _ref, _results;

    limiter = 999;
    diagonals = [];
    ear = [];
    facelen = verts.length;
    XOR = function(x, y) {
      return (x || y) && !(x && y);
    };
    Area2 = function(Va, Vb, Vc) {
      return (Vb[0] - Va[0]) * (Vc[1] - Va[1]) - (Vc[0] - Va[0]) * (Vb[1] - Va[1]);
    };
    Left = function(Va, Vb, Vc) {
      return Area2(Va, Vb, Vc) > 0;
    };
    LeftOn = function(Va, Vb, Vc) {
      return Area2(Va, Vb, Vc) >= 0;
    };
    Collinear = function(Va, Vb, Vc) {
      return Area2(Va, Vb, Vc) === 0;
    };
    Between = function(Va, Vb, Vc) {
      if (Collinear(Va, Vb, Vc)) {
        return false;
      }
      if (Va[0] !== Vb[0]) {
        return (Va[0] <= Vc[0]) && (Vc[0] <= Vb[0]) || (Va[0] >= Vc[0]) && (Vc[0] >= Vb[0]);
      } else {
        return (Va[1] <= Vc[1]) && (Vc[1] <= Vb[1]) || (Va[1] >= Vc[1]) && (Vc[1] >= Vb[1]);
      }
    };
    IntersectProp = function(Va, Vb, Vc, Vd) {
      if (Collinear(Va, Vb, Vc) || Collinear(Va, Vb, Vd) || Collinear(Vc, Vd, Va) || Collinear(Vc, Vd, Vb)) {
        return false;
      }
      return XOR(Left(Va, Vb, Vc), Left(Va, Vb, Vd)) && XOR(Left(Vc, Vd, Va), Left(Vc, Vd, Vb));
    };
    Intersect = function(Va, Vb, Vc, Vd) {
      if (IntersectProp(Va, Vb, Vc, Vd)) {
        return true;
      } else {
        if (Between(Va, Vb, Vc) || Between(Va, Vb, Vd) || Between(Vc, Vd, Va) || Between(Vc, Vd, Vb)) {
          return true;
        } else {
          return false;
        }
      }
    };
    InCone = function(a, b) {
      var a0, a1;

      a1 = (a + 1 + facelen) % facelen;
      a0 = (a - 1 + facelen) % facelen;
      if (LeftOn(verts[a], verts[a1], verts[a0])) {
        return Left(verts[a], verts[b], verts[a0]) && Left(verts[b], verts[a], verts[a1]);
      }
      return !(LeftOn(verts[a], verts[b], verts[a1]) && LeftOn(verts[b], verts[a], verts[a0]));
    };
    Diagonalie = function(a, b) {
      var c, c1;

      c = 0;
      while (true) {
        c1 = (c + 1 + facelen) % facelen;
        if ((c !== a) && (c1 !== a) && (c !== b) && (c1 !== b) && IntersectProp(verts[a], verts[b], verts[c], verts[c1])) {
          return false;
        }
        c = (c + 1 + facelen) % facelen;
        if (c === 0) {
          break;
        }
      }
      return true;
    };
    Diagonal = function(a, b) {
      return InCone(a, b) && InCone(b, a) && Diagonalie(a, b);
    };
    v1 = 0;
    while (true) {
      v2 = (v1 + 1 + facelen) % facelen;
      v0 = (v1 - 1 + facelen) % facelen;
      ear[v1] = Diagonal(v0, v2);
      v1 = (v1 + 1 + facelen) % facelen;
      if (v1 === 0) {
        break;
      }
    }
    origIdx = (function() {
      _results = [];
      for (var _i = 0, _ref = facelen - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    n = facelen;
    z = limiter;
    head = 0;
    while (z > 0 && n > 3) {
      z -= 1;
      v2 = head;
      y = limiter;
      while (true) {
        y -= 1;
        broke = false;
        if (ear[v2]) {
          v3 = (v2 + 1 + facelen) % facelen;
          v4 = (v3 + 1 + facelen) % facelen;
          v1 = (v2 - 1 + facelen) % facelen;
          v0 = (v1 - 1 + facelen) % facelen;
          diagonals.push([origIdx[v1], origIdx[v3]]);
          ear[v1] = Diagonal(v0, v3);
          ear[v3] = Diagonal(v1, v4);
          verts = verts.slice(0, +v2 + 1 || 9e9).concat(verts.slice(v3));
          origIdx = origIdx.slice(0, +v2 + 1 || 9e9).concat(origIdx.slice(v3));
          if (v0 > v2) {
            v0 -= 1;
          }
          if (v1 > v2) {
            v1 -= 1;
          }
          if (v3 > v2) {
            v3 -= 1;
          }
          if (v4 > v2) {
            v4 -= 1;
          }
          facelen--;
          head = v3;
          n--;
          broke = true;
        }
        v2 = (v2 + 1 + facelen) % facelen;
        if (!(y > 0 && !broke && v2 !== head)) {
          break;
        }
      }
    }
    return diagonals;
  };

  triEq = function(tri1, tri2) {
    if (((tri1[0] === tri2[0]) && (tri1[1] === tri2[1]) && (tri1[2] === tri2[2])) || (tri1[0] === tri2[1]) && (tri1[1] === tri2[2]) && (tri1[2] === tri2[0]) || (tri1[0] === tri2[2]) && (tri1[1] === tri2[0]) && (tri1[2] === tri2[1])) {
      return true;
    } else {
      return false;
    }
  };

  diagsToTris = function(f, diags) {
    var already_present, d, e1, e2, edges, extant_tri, i, redges, tri, tris, uniques, v1, v2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

    edges = [];
    redges = [];
    _ref = (function() {
      var _j, _ref, _results;

      _results = [];
      for (i = _j = 0, _ref = f.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
        _results.push([i, (i + 1) % f.length]);
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], v1 = _ref1[0], v2 = _ref1[1];
      edges[v1] = [v2];
      redges[v2] = [v1];
    }
    for (_j = 0, _len1 = diags.length; _j < _len1; _j++) {
      d = diags[_j];
      edges[d[0]].push(d[1]);
      edges[d[1]].push(d[0]);
      redges[d[0]].push(d[1]);
      redges[d[1]].push(d[0]);
    }
    tris = [];
    for (_k = 0, _len2 = diags.length; _k < _len2; _k++) {
      d = diags[_k];
      _ref2 = edges[d[1]];
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        e1 = _ref2[_l];
        _ref3 = redges[d[0]];
        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
          e2 = _ref3[_m];
          if (e1 === e2) {
            tris.push([d[0], d[1], e1]);
          }
        }
      }
      _ref4 = edges[d[0]];
      for (_n = 0, _len5 = _ref4.length; _n < _len5; _n++) {
        e1 = _ref4[_n];
        _ref5 = redges[d[1]];
        for (_o = 0, _len6 = _ref5.length; _o < _len6; _o++) {
          e2 = _ref5[_o];
          if (e1 === e2) {
            tris.push([d[1], d[0], e1]);
          }
        }
      }
    }
    uniques = [tris.pop()];
    for (_p = 0, _len7 = tris.length; _p < _len7; _p++) {
      tri = tris[_p];
      already_present = false;
      for (_q = 0, _len8 = uniques.length; _q < _len8; _q++) {
        extant_tri = uniques[_q];
        if (triEq(tri, extant_tri)) {
          already_present = true;
          break;
        }
      }
      if (!already_present) {
        uniques.push(tri);
      }
    }
    return uniques;
  };

  triangulate = function(poly, colors) {
    var TwoDface, diags, f, i, j, newpoly, tri, tris, v, _i, _j, _len, _len1, _ref;

    colors = colors || false;
    console.log("Triangulating faces of " + poly.name + "...");
    newpoly = new polyhedron();
    newpoly.xyz = clone(poly.xyz);
    newpoly.face_class = [];
    _ref = poly.face;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      f = _ref[i];
      if (f.length > 3) {
        TwoDface = project2dface((function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
            v = f[_j];
            _results.push(poly.xyz[v]);
          }
          return _results;
        })());
        diags = getDiagonals(TwoDface);
        tris = diagsToTris(f, diags);
        for (j = _j = 0, _len1 = tris.length; _j < _len1; j = ++_j) {
          tri = tris[j];
          newpoly.face.push([f[tri[0]], f[tri[1]], f[tri[2]]]);
          if (colors) {
            newpoly.face_class.push(poly.face_class[i]);
          }
        }
      } else {
        newpoly.face.push([f[0], f[1], f[2]]);
        if (colors) {
          newpoly.face_class.push(poly.face_class[i]);
        }
      }
    }
    newpoly.name = poly.name;
    return newpoly;
  };

  topolog = function(poly) {
    var f, str, v, _i, _j, _len, _len1, _ref;

    str = "";
    _ref = poly.face;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      for (_j = 0, _len1 = f.length; _j < _len1; _j++) {
        v = f[_j];
        str += "" + v + "->";
      }
      str += "\n";
    }
    return console.log(str);
  };

  testrig = function() {
    var op, ops, seed, seeds, _i, _j, _len, _len1;

    seeds = ["T", "O", "C", "I", "D", "P3", "P4", "A4", "A5", "Y3", "Y4"];
    ops = ["k", "a", "g", "p", "d", "n", "x", "*"];
    console.log("===== Test Basic Ops =====");
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      op = ops[_i];
      console.log("Operator " + op);
      for (_j = 0, _len1 = seeds.length; _j < _len1; _j++) {
        seed = seeds[_j];
        console.log(op + seed + ":", generatePoly(op + seed));
      }
    }
    return console.log("===== Done Testing Basic Ops =====");
  };

  PEG_parser_spec = '/* series of opspecs */\nstart  = opspec+\n\n/* opspec one of:\n A  - single letter\n A3 - single letter and float\n B(5,4.3,3) - function call format w. float args\n*/\nopspec =\n   let:opcode args:opargs {return {"op":let,"args":args};}\n/ let:opcode float:float     {return {"op":let,"args":[float]};}\n/ let:opcode                     {return {"op":let,"args":[]};}\n\n/*\nparentheses surrounding comma-delimited list of floats i.e.\n( 1 , 3.2, 4 ) or (1) or (2,3)\n*/\nopargs = "("\n           num:( float:float ","? {return float} )+\n         ")" {return num;}\n\n/* just a letter */\nopcode = op:[a-zA-Z] {return op;}\n\n/* standard numerical types */\nint   = digits:[0-9-]+   { return parseInt(digits.join(""), 10);  }\nfloat = digits:[0-9.-]+  { return parseFloat(digits.join(""), 10); }';

  op_parser = PEG.buildParser(PEG_parser_spec);

  dispatch = function(fn, args) {
    return fn.apply(this, args || []);
  };

  basemap = {
    "T": tetrahedron,
    "O": octahedron,
    "C": cube,
    "I": icosahedron,
    "D": dodecahedron,
    "P": prism,
    "A": antiprism,
    "Y": pyramid
  };

  opmap = {
    "d": dual,
    "k": kisN,
    "a": ambo,
    "g": gyro,
    "p": propellor,
    "r": reflect,
    "n": insetN,
    "x": extrudeN,
    "l": stellaN,
    "z": triangulate,
    "h": hollow,
    "K": canonicalXYZ,
    "C": canonicalize,
    "A": adjustXYZ
  };

  specreplacements = [[/e/g, "aa"], [/b/g, "ta"], [/o/g, "jj"], [/m/g, "kj"], [/t(\d*)/g, "dk$1d"], [/j/g, "dad"], [/s/g, "dgd"], [/dd/g, ""], [/ad/g, "a"], [/gd/g, "g"], [/aO/g, "aC"], [/aI/g, "aD"], [/gO/g, "gC"], [/gI/g, "gD"]];

  getOps = function(notation) {
    var equiv, expanded, orig, _i, _len, _ref;

    expanded = notation;
    for (_i = 0, _len = specreplacements.length; _i < _len; _i++) {
      _ref = specreplacements[_i], orig = _ref[0], equiv = _ref[1];
      expanded = expanded.replace(orig, equiv);
    }
    console.log("" + notation + " executed as " + expanded);
    return expanded;
  };

  newgeneratePoly = function(notation) {
    var baseargs, basefunc, op, opargs, opfunc, oplist, ops_spec, poly, _i, _len;

    ops_spec = getOps(notation);
    oplist = op_parser.parse(ops_spec).reverse();
    op = oplist.shift();
    basefunc = basemap[op["op"]];
    baseargs = op["args"];
    poly = dispatch(basefunc, baseargs);
    for (_i = 0, _len = oplist.length; _i < _len; _i++) {
      op = oplist[_i];
      opfunc = opmap[op["op"]];
      opargs = [poly].concat(op["args"]);
      poly = dispatch(opfunc, opargs);
    }
    poly.xyz = recenter(poly.xyz, poly.edges());
    poly.xyz = rescale(poly.xyz);
    poly = paintPolyhedron(poly);
    return poly;
  };

  ctx = {};

  CANVAS_WIDTH = 500;

  CANVAS_HEIGHT = 400;

  globPolys = {};

  globRotM = clone(eye3);

  globlastRotM = clone(eye3);

  perspective_scale = 800;

  persp_z_max = 5;

  persp_z_min = 0;

  persp_ratio = 0.8;

  _2d_x_offset = CANVAS_WIDTH / 2;

  _2d_y_offset = CANVAS_HEIGHT / 2;

  globtime = new Date();

  BG_CLEAR = true;

  BG_COLOR = "rgba(255,255,255,1.0)";

  COLOR_METHOD = "area";

  PaintMode = "fillstroke";

  ctx_linewidth = 0.5;

  MOUSEDOWN = false;

  LastMouseX = 0;

  LastMouseY = 0;

  LastSphVec = [1, 0, 0];

  DEFAULT_RECIPES = ["T"];

  saveText = function(text, filename) {
    var BB, bb;

    BB = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
    bb = new BB();
    bb.append(text);
    return saveAs(bb.getBlob("text/plain;charset=" + document.characterSet), filename);
  };

  parseurl = function() {
    var a, d, e, q, r, urlParams;

    urlParams = {};
    a = /\+/g;
    r = /([^&=]+)=?([^&]*)/g;
    d = function(s) {
      return decodeURIComponent(s.replace(a, " "));
    };
    q = window.location.search.substring(1);
    while (e = r.exec(q)) {
      urlParams[d(e[1])] = d(e[2]);
    }
    return urlParams;
  };

  init = function() {
    var canvas;

    canvas = $('#poly');
    canvas.width(CANVAS_WIDTH);
    canvas.height(CANVAS_HEIGHT);
    ctx = canvas[0].getContext("2d");
    ctx.lineWidth = ctx_linewidth;
    if (BG_CLEAR) {
      return ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    } else {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = BG_COLOR;
      return ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }
  };

  clear = function() {
    if (BG_CLEAR) {
      return ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    } else {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.fillStyle = BG_COLOR;
      return ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }
  };

  drawpoly = function(poly, tvec) {
    var clr, face, face_verts, fno, illum, normals, oldxyz, v, v0, wtfs, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;

    tvec || (tvec = [3, 3, 3]);
    oldxyz = _.map(poly.xyz, function(x) {
      return x;
    });
    poly.xyz = _.map(poly.xyz, function(x) {
      return mv3(globRotM, x);
    });
    sortfaces(poly);
    window.polyobj = clone(poly);
    wtfs = [
      polygonclip((function() {
        var _i, _len, _ref, _results;

        _ref = poly.face[0];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(poly.xyz[v]);
        }
        return _results;
      })(), (function() {
        var _i, _len, _ref, _results;

        _ref = poly.face[2];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(poly.xyz[v]);
        }
        return _results;
      })())
    ];
    normals = poly.normals();
    _ref = poly.face;
    for (fno = _i = 0, _len = _ref.length; _i < _len; fno = ++_i) {
      face = _ref[fno];
      if (dot(normals[fno], [0, 0, 1]) < 0) {
        continue;
      }
      ctx.beginPath();
      v0 = face[face.length - 1];
      _ref1 = perspT(add(tvec, poly.xyz[v0]), persp_z_max, persp_z_min, persp_ratio, perspective_scale), x = _ref1[0], y = _ref1[1];
      ctx.moveTo(x + _2d_x_offset, y + _2d_y_offset);
      for (_j = 0, _len1 = face.length; _j < _len1; _j++) {
        v = face[_j];
        _ref2 = perspT(add(tvec, poly.xyz[v]), persp_z_max, persp_z_min, persp_ratio, perspective_scale), x = _ref2[0], y = _ref2[1];
        ctx.lineTo(x + _2d_x_offset, y + _2d_y_offset);
      }
      clr = palette(poly.face_class[fno]);
      face_verts = (function() {
        var _k, _len2, _results;

        _results = [];
        for (_k = 0, _len2 = face.length; _k < _len2; _k++) {
          v = face[_k];
          _results.push(poly.xyz[v]);
        }
        return _results;
      })();
      illum = dot(normal(face_verts), unit([1, -1, 0]));
      clr = mult((illum / 2.0 + .5) * 0.7 + 0.3, clr);
      if (PaintMode === "fill" || PaintMode === "fillstroke") {
        ctx.fillStyle = "rgba(" + (round(clr[0] * 255)) + ", " + (round(clr[1] * 255)) + ", " + (round(clr[2] * 255)) + ", " + 1.0 + ")";
        ctx.fill();
        ctx.strokeStyle = "rgba(" + (round(clr[0] * 255)) + ", " + (round(clr[1] * 255)) + ", " + (round(clr[2] * 255)) + ", " + 1.0 + ")";
        ctx.stroke();
      }
      if (PaintMode === "fillstroke") {
        ctx.fillStyle = "rgba(" + (round(clr[0] * 255)) + ", " + (round(clr[1] * 255)) + ", " + (round(clr[2] * 255)) + ", " + 1.0 + ")";
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0, .3)";
        ctx.stroke();
      }
      if (PaintMode === "stroke") {
        ctx.strokeStyle = "rgba(0,0,0, .8)";
        ctx.stroke();
      }
    }
    for (_k = 0, _len2 = wtfs.length; _k < _len2; _k++) {
      face = wtfs[_k];
      ctx.beginPath();
      v0 = face[face.length - 1];
      x = v0[0], y = v0[1];
      ctx.moveTo(10 * x + _2d_x_offset, 10 * y + _2d_y_offset);
      for (_l = 0, _len3 = face.length; _l < _len3; _l++) {
        v = face[_l];
        x = v[0], y = v[1];
        ctx.lineTo(10 * x + _2d_x_offset, 10 * y + _2d_y_offset);
      }
      ctx.lineWidth = 1.0;
      ctx.strokeStyle = "rgba(0,0,0, 1.0)";
      ctx.stroke();
      ctx.lineWidth = ctx_linewidth;
    }
    return poly.xyz = oldxyz;
  };

  drawShape = function() {
    var i, p, _i, _len, _results;

    clear();
    _results = [];
    for (i = _i = 0, _len = globPolys.length; _i < _len; i = ++_i) {
      p = globPolys[i];
      _results.push(drawpoly(p, [0 + 3 * i, 0, 3]));
    }
    return _results;
  };

  animateShape = function() {
    var globtheta, i, p, _i, _len;

    clear();
    globtheta = (2 * Math.PI) / 180.0 * globtime.getSeconds() * 0.1;
    for (i = _i = 0, _len = globPolys.length; _i < _len; i = ++_i) {
      p = globPolys[i];
      drawpoly(p, [0 + 3 * i, 0, 3]);
    }
    return setTimeout(animateShape, 100);
  };

  $(function() {
    var specs, urlParams;

    init();
    urlParams = parseurl();
    if ("recipe" in urlParams) {
      specs = [urlParams["recipe"]];
      $("#spec").val(specs);
    } else {
      specs = [randomchoice(DEFAULT_RECIPES)];
      $("#spec").val(specs);
    }
    $("#palette").val(PALETTE.reduce(function(x, y) {
      return x + " " + y;
    }));
    globPolys = _.map(specs, function(x) {
      return newgeneratePoly(x);
    });
    drawShape();
    $("#spec").change(function(e) {
      specs = $("#spec").val().split(/\s+/g).slice(0, 2);
      globPolys = _.map(specs, function(x) {
        return newgeneratePoly(x);
      });
      return drawShape();
    });
    $("#palette").change(function(e) {
      PALETTE = $(this).val().split(/\s+/g);
      return drawShape();
    });
    $("#poly").mousewheel(function(e, delta, deltaX, deltaY) {
      e.preventDefault();
      perspective_scale *= (10 + delta) / 10;
      return drawShape();
    });
    $("#poly").mousedown(function(e) {
      var tmpvec;

      e.preventDefault();
      MOUSEDOWN = true;
      LastMouseX = e.clientX - $(this).offset().left;
      LastMouseY = e.clientY - ($(this).offset().top - $(window).scrollTop());
      tmpvec = invperspT(LastMouseX, LastMouseY, _2d_x_offset, _2d_y_offset, persp_z_max, persp_z_min, persp_ratio, perspective_scale);
      if (tmpvec[0] * tmpvec[1] * tmpvec[2] * 0 === 0) {
        LastSphVec = tmpvec;
      }
      return globlastRotM = clone(globRotM);
    });
    $("#poly").mouseup(function(e) {
      e.preventDefault();
      return MOUSEDOWN = false;
    });
    $("#poly").mouseleave(function(e) {
      e.preventDefault();
      return MOUSEDOWN = false;
    });
    $("#poly").mousemove(function(e) {
      var MouseX, MouseY, SphVec;

      e.preventDefault();
      if (MOUSEDOWN) {
        MouseX = e.clientX - $(this).offset().left;
        MouseY = e.clientY - ($(this).offset().top - $(window).scrollTop());
        SphVec = invperspT(MouseX, MouseY, _2d_x_offset, _2d_y_offset, persp_z_max, persp_z_min, persp_ratio, perspective_scale);
        if (SphVec[0] * SphVec[1] * SphVec[2] * 0 === 0 && LastSphVec[0] * LastSphVec[1] * LastSphVec[2] * 0 === 0) {
          globRotM = mm3(getVec2VecRotM(LastSphVec, SphVec), globlastRotM);
        }
        return drawShape();
      }
    });
    $("#strokeonly").click(function(e) {
      PaintMode = "stroke";
      return drawShape();
    });
    $("#fillonly").click(function(e) {
      PaintMode = "fill";
      return drawShape();
    });
    $("#fillandstroke").click(function(e) {
      PaintMode = "fillstroke";
      return drawShape();
    });
    $("#siderot").click(function(e) {
      globRotM = vec_rotm(PI / 2, 0, 1, 0);
      return drawShape();
    });
    $("#toprot").click(function(e) {
      globRotM = vec_rotm(PI / 2, 1, 0, 0);
      return drawShape();
    });
    $("#frontrot").click(function(e) {
      globRotM = rotm(0, 0, 0);
      return drawShape();
    });
    $("#pngsavebutton").click(function(e) {
      var canvas, filename, spec;

      getSVG(clone(globPolys[0]));
      canvas = $("#poly")[0];
      spec = $("#spec").val().split(/\s+/g)[0];
      filename = "polyhedronisme-" + spec.replace(/\([^\)]+\)/g, "") + ".png";
      return canvas.toBlob(function(blob) {
        return saveAs(blob, filename);
      });
    });
    $("#objsavebutton").click(function(e) {
      var filename, objtxt, spec;

      objtxt = globPolys[0].toOBJ();
      spec = $("#spec").val().split(/\s+/g)[0];
      filename = "polyhedronisme-" + spec.replace(/\([^\)]+\)/g, "") + ".obj";
      return saveText(objtxt, filename);
    });
    return $("#x3dsavebutton").click(function(e) {
      var filename, spec, triangulated, x3dtxt;

      triangulated = triangulate(globPolys[0], true);
      x3dtxt = triangulated.toVRML();
      spec = $("#spec").val().split(/\s+/g)[0];
      filename = "polyhedronisme-" + spec.replace(/\([^\)]+\)/g, "") + ".wrl";
      return saveText(x3dtxt, filename);
    });
  });

  to2Dfaces = function(poly, tvec) {
    var clr, face, face_verts, facecolors, fno, illum, normals, twoDface, twoDfaces, v, x, y, _i, _j, _len, _len1, _ref, _ref1;

    tvec || (tvec = [3, 3, 3]);
    poly.xyz = _.map(poly.xyz, function(x) {
      return mv3(globRotM, x);
    });
    normals = _.map(poly.normals(), function(x) {
      return mv3(globRotM, x);
    });
    sortfaces(poly);
    poly.face = poly.face.reverse();
    twoDfaces = [];
    facecolors = [];
    _ref = poly.face;
    for (fno = _i = 0, _len = _ref.length; _i < _len; fno = ++_i) {
      face = _ref[fno];
      twoDface = [];
      for (_j = 0, _len1 = face.length; _j < _len1; _j++) {
        v = face[_j];
        _ref1 = perspT(add(tvec, poly.xyz[v]), persp_z_max, persp_z_min, persp_ratio, perspective_scale), x = _ref1[0], y = _ref1[1];
        twoDface.push([x + _2d_x_offset, y + _2d_y_offset]);
      }
      twoDfaces.push(twoDface);
      console.log("twoDface", _.map(twoDface, function(ar) {
        return " [" + ar[0] + "," + ar[1] + "] ";
      }));
      clr = palette(poly.face_class[fno]);
      face_verts = (function() {
        var _k, _len2, _results;

        _results = [];
        for (_k = 0, _len2 = face.length; _k < _len2; _k++) {
          v = face[_k];
          _results.push(poly.xyz[v]);
        }
        return _results;
      })();
      illum = dot(normal(face_verts), unit([1, -1, 0]));
      clr = mult((illum / 2.0 + .5) * 0.7 + 0.3, clr);
      facecolors.push(clr);
    }
    return [twoDfaces, facecolors];
  };

  Signed2DTriArea = function(a, b, c) {
    return (a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]);
  };

  Test2DSegmentSegment = function(a, b, c, d) {
    var a1, a2, a3, a4, p, t;

    a1 = Signed2DTriArea(a, b, d);
    a2 = Signed2DTriArea(a, b, c);
    if (a1 !== 0.0 && a2 !== 0.0 && a1 * a2 < 0.0) {
      a3 = Signed2DTriArea(c, d, a);
      a4 = Signed2DTriArea(c, d, b);
      if (a3 * a4 < 0.0) {
        t = a3 / (a3 - a4);
        p = [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];
        return p;
      }
    }
    return false;
  };

  twoDpolygonarea = function(xys) {
    var area, v1, v2, _i, _len, _ref;

    area = 0.0;
    v1 = xys[0];
    _ref = xys.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v2 = _ref[_i];
      area += (v1[0] + v2[0]) * (v1[1] - v2[1]);
      v1 = v2;
    }
    return area * 0.5;
  };

  clockwisepoly = function(xys) {
    return twoDpolygonarea(xys) > 0;
  };

  idxof = function(vlist, vtest) {
    var i, v, _i, _len;

    for (i = _i = 0, _len = vlist.length; _i < _len; i = ++_i) {
      v = vlist[i];
      if (abs(v[0] - vtest[0]) + abs(v[1] - vtest[1]) < 1e-6) {
        return i;
      }
    }
    return -1;
  };

  intersectionGraph = function(_2dfaceA, _2dfaceB) {
    var eA, eB, edgesA, edgesB, i, idx, idx0, intersectpts, j, k, newedgesA, newedgesB, newvertsA, newvertsB, p, v, vA, vB, verts, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1;

    verts = [];
    for (_i = 0, _len = _2dfaceA.length; _i < _len; _i++) {
      v = _2dfaceA[_i];
      if (idxof(verts, v) === -1) {
        verts.push(v);
      }
    }
    for (_j = 0, _len1 = _2dfaceB.length; _j < _len1; _j++) {
      v = _2dfaceB[_j];
      if (idxof(verts, v) === -1) {
        verts.push(v);
      }
    }
    edgesA = [];
    idx0 = idxof(verts, _2dfaceA[_2dfaceA.length - 1]);
    for (_k = 0, _len2 = _2dfaceA.length; _k < _len2; _k++) {
      v = _2dfaceA[_k];
      idx = idxof(verts, v);
      edgesA.push([idx0, idx]);
      idx0 = idx;
    }
    edgesB = [];
    idx0 = idxof(verts, _2dfaceB[_2dfaceB.length - 1]);
    for (_l = 0, _len3 = _2dfaceB.length; _l < _len3; _l++) {
      v = _2dfaceB[_l];
      idx = idxof(verts, v);
      edgesB.push([idx0, idx]);
      idx0 = idx;
    }
    newvertsA = (function() {
      var _m, _ref, _results;

      _results = [];
      for (i = _m = 0, _ref = edgesA.length - 1; 0 <= _ref ? _m <= _ref : _m >= _ref; i = 0 <= _ref ? ++_m : --_m) {
        _results.push([]);
      }
      return _results;
    })();
    newvertsB = (function() {
      var _m, _ref, _results;

      _results = [];
      for (i = _m = 0, _ref = edgesB.length - 1; 0 <= _ref ? _m <= _ref : _m >= _ref; i = 0 <= _ref ? ++_m : --_m) {
        _results.push([]);
      }
      return _results;
    })();
    intersectpts = [];
    for (i = _m = 0, _len4 = edgesA.length; _m < _len4; i = ++_m) {
      eA = edgesA[i];
      for (j = _n = 0, _len5 = edgesB.length; _n < _len5; j = ++_n) {
        eB = edgesB[j];
        if (p = Test2DSegmentSegment(verts[eA[0]], verts[eA[1]], verts[eB[0]], verts[eB[1]])) {
          newvertsA[i].push(p);
          newvertsB[j].push(p);
          if (idxof(verts, p) === -1) {
            verts.push(p);
          }
          intersectpts.push(idxof(verts, p));
        }
      }
    }
    newedgesA = [];
    for (i = _o = 0, _len6 = newvertsA.length; _o < _len6; i = ++_o) {
      vA = newvertsA[i];
      if (newvertsA[i].length > 0) {
        newvertsA[i].sort(function(pa, pb) {
          return mag(pa - verts[edgesA[i][0]]) - mag(pb - verts[edgesA[i][0]]);
        });
        newedgesA.push([edgesA[i][0], idxof(verts, newvertsA[i][0])]);
        _ref = newvertsA[i].slice(1);
        for (k = _p = 0, _len7 = _ref.length; _p < _len7; k = ++_p) {
          v = _ref[k];
          newedgesA.push([idxof(verts, newvertsA[i][k]), idxof(verts, newvertsA[i][k + 1])]);
        }
        newedgesA.push([idxof(verts, newvertsA[i][newvertsA[i].length - 1]), edgesA[i][1]]);
      } else {
        newedgesA.push(edgesA[i]);
      }
    }
    newedgesB = [];
    for (i = _q = 0, _len8 = newvertsB.length; _q < _len8; i = ++_q) {
      vB = newvertsB[i];
      if (newvertsB[i].length > 0) {
        newvertsB[i].sort(function(pa, pb) {
          return mag(pa - verts[edgesB[i][0]]) - mag(pb - verts[edgesB[i][0]]);
        });
        newedgesB.push([edgesB[i][0], idxof(verts, newvertsB[i][0])]);
        _ref1 = newvertsB[i].slice(1);
        for (k = _r = 0, _len9 = _ref1.length; _r < _len9; k = ++_r) {
          v = _ref1[k];
          newedgesB.push([idxof(verts, newvertsB[i][k]), idxof(verts, newvertsB[i][k + 1])]);
        }
        newedgesB.push([idxof(verts, newvertsB[i][newvertsB[i].length - 1]), edgesB[i][1]]);
      } else {
        newedgesB.push(edgesB[i]);
      }
    }
    return [verts, newedgesA, newedgesB, intersectpts];
  };

  pointInPoly = function(_2dfaceA, pt) {
    var eA, edgesA, idx, idx0, isects, v, verts, _i, _j, _k, _len, _len1, _len2;

    verts = [];
    for (_i = 0, _len = _2dfaceA.length; _i < _len; _i++) {
      v = _2dfaceA[_i];
      if (idxof(verts, v) === -1) {
        verts.push(v);
      }
    }
    edgesA = [];
    idx0 = idxof(verts, _2dfaceA[_2dfaceA.length - 1]);
    for (_j = 0, _len1 = _2dfaceA.length; _j < _len1; _j++) {
      v = _2dfaceA[_j];
      idx = idxof(verts, v);
      edgesA.push([idx0, idx]);
      idx0 = idx;
    }
    isects = 0;
    for (_k = 0, _len2 = edgesA.length; _k < _len2; _k++) {
      eA = edgesA[_k];
      if (Test2DSegmentSegment(verts[eA[0]], verts[eA[1]], pt, [pt[0], 10000])) {
        isects++;
      }
    }
    console.log("pointInpoly called : " + isects, isects % 2 !== 0);
    if (isects % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };

  AminusB = function(A, B) {
    var Agraph, Bgraph, e, idx, intersectpts, itrCTR, movingpt, newedgesA, newedgesB, newpoly, newpolys, pt, state, sullied, verts, _i, _j, _k, _len, _len1, _len2, _ref;

    _ref = intersectionGraph(A, B.reverse()), verts = _ref[0], newedgesA = _ref[1], newedgesB = _ref[2], intersectpts = _ref[3];
    Agraph = {};
    for (_i = 0, _len = newedgesA.length; _i < _len; _i++) {
      e = newedgesA[_i];
      Agraph[e[0]] = e[1];
    }
    Bgraph = {};
    for (_j = 0, _len1 = newedgesB.length; _j < _len1; _j++) {
      e = newedgesB[_j];
      Bgraph[e[0]] = e[1];
    }
    sullied = {};
    if (intersectpts.length === 0) {
      if (pointInPoly(B, A[0])) {
        return [];
      } else {
        return [A];
      }
    }
    newpolys = [];
    for (_k = 0, _len2 = intersectpts.length; _k < _len2; _k++) {
      pt = intersectpts[_k];
      state = "B";
      if (sullied[pt + state]) {
        continue;
      }
      newpoly = [];
      movingpt = pt;
      sullied[movingpt + state] = true;
      itrCTR = 0;
      while (movingpt !== pt && itrCTR < 1000) {
        if (Agraph[pt] && Bgraph[pt]) {
          state = state === "A" ? "B" : "A";
        }
        if (state === "A") {
          movingpt = Agraph[movingpt];
        } else {
          movingpt = Bgraph[movingpt];
        }
        newpoly.push(movingpt);
        sullied[movingpt + state] = true;
      }
      newpolys.push((function() {
        var _l, _len3, _results;

        _results = [];
        for (_l = 0, _len3 = newpoly.length; _l < _len3; _l++) {
          idx = newpoly[_l];
          _results.push(verts[idx]);
        }
        return _results;
      })());
    }
    return _.filter(newpolys, clockwisepoly);
  };

  getSVG = function(poly) {
    var f, fA, fB, facecolors, frontfaces, fset, fsetnew, svg_close, svg_open, svgtxt, twoDfaces, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;

    console.log(poly.data());
    _ref = to2Dfaces(poly), twoDfaces = _ref[0], facecolors = _ref[1];
    frontfaces = [];
    frontfaces.push(twoDfaces[0]);
    _ref1 = twoDfaces.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      fA = _ref1[_i];
      fset = [fA];
      for (_j = 0, _len1 = frontfaces.length; _j < _len1; _j++) {
        fB = frontfaces[_j];
        fsetnew = [];
        for (_k = 0, _len2 = fset.length; _k < _len2; _k++) {
          f = fset[_k];
          fsetnew = fsetnew.concat(AminusB(f, fB));
        }
        fset = fsetnew;
      }
      frontfaces = frontfaces.concat(fset);
    }
    frontfaces = frontfaces.reverse();
    console.log(frontfaces.length, frontfaces);
    svg_open = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1 Tiny//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd\">\n<svg version=\"1.1\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n         x=\"0px\" y=\"0px\" width=\"1024px\" height=\"768px\" viewBox=\"0 0 1024 768\" overflow=\"inherit\" xml:space=\"preserve\">\n";
    svg_close = "</svg>";
    svgtxt = svg_open;
    for (_l = 0, _len3 = frontfaces.length; _l < _len3; _l++) {
      f = frontfaces[_l];
      svgtxt += '<path fill="#25DF00" stroke="#000000" d="';
      svgtxt += 'M' + f[0][0] + "," + f[0][1];
      _ref2 = f.slice(1);
      for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
        v = _ref2[_m];
        svgtxt += 'L' + v[0] + "," + v[1];
      }
      svgtxt += 'z"/>\n';
    }
    svgtxt += svg_close;
    return console.log(svgtxt);
  };

}).call(this);
