const{random,round,floor,sqrt,sin,cos,tan,asin,acos,atan,abs,pow,log,PI,LN10}=Math,log10=e=>log(e)/LN10,sigfigs=function(e,n){const d=pow(10,log10(e)-floor(log10(e)));return`${round(d*(n-1))}`};var clone=function(e){if(null==e||"object"!=typeof e)return e;const n=new e.constructor;for(let d in e)n[d]=clone(e[d]);return n};const randomchoice=function(e){const d=floor(random()*e.length);return e[d]},mult=(e,n)=>[e*n[0],e*n[1],e*n[2]],_mult=(e,n)=>[e[0]*n[0],e[1]*n[1],e[2]*n[2]],add=(e,n)=>[e[0]+n[0],e[1]+n[1],e[2]+n[2]],sub=(e,n)=>[e[0]-n[0],e[1]-n[1],e[2]-n[2]],dot=(e,n)=>e[0]*n[0]+e[1]*n[1]+e[2]*n[2],cross=(e,n)=>[e[1]*n[2]-e[2]*n[1],e[2]*n[0]-e[0]*n[2],e[0]*n[1]-e[1]*n[0]],mag=e=>sqrt(dot(e,e)),mag2=e=>dot(e,e),unit=e=>mult(1/sqrt(mag2(e)),e),midpoint=(e,n)=>mult(1/2,add(e,n)),tween=(e,n,d)=>[(1-d)*e[0]+d*n[0],(1-d)*e[1]+d*n[1],(1-d)*e[2]+d*n[2]],oneThird=(e,n)=>tween(e,n,1/3),reciprocal=e=>mult(1/mag2(e),e),tangentPoint=function(e,n){const a=sub(n,e);return sub(e,mult(dot(a,e)/mag2(a),a))},edgeDist=(e,n)=>sqrt(mag2(tangentPoint(e,n))),linePointDist2=function(e,n,d){let a;const f=sub(n,e),l=sub(e,d),i=sub(n,d),u=mag2(f),c=-dot(l,f)/u;return a=0>=c?mag2(l):1<=c?mag2(i):mag2(cross(f,l))/u,a},orthogonal=function(e,n,d){const a=sub(n,e),f=sub(d,n);return cross(a,f)},intersect=function(e,n,d){for(let a of e)for(let e of n)if(a===e)for(let e of d)if(a===e)return a;return null},calcCentroid=function(e){let n=[0,0,0];for(let d of e)n=add(n,d);return mult(1/e.length,n)},normal=function(e){let n=[0,0,0],[d,a]=e.slice(-2);for(let f of e)n=add(n,orthogonal(d,a,f)),[d,a]=[a,f];return unit(n)},convexarea=function(e){let n=0,[d,a]=e.slice(0,2);for(let f of e.slice(2))n+=mag(cross(sub(a,d),sub(f,d))),a=f;return n},faceSignature=function(e){let n;const d=[];let[a,f]=e.slice(0,2);for(let n of e.slice(2))d.push(mag(cross(sub(f,a),sub(n,a)))),f=n;d.sort((e,n)=>e-n);let l="";for(n of d)l+=sigfigs(n,2);for(n of d.reverse())l+=sigfigs(n,2);return l},project2dface=function(e){let d=clone(e);const a=e[0];d=_.map(d,e=>e-a);const f=normal(e),n=unit(calcCentroid(e)),l=cross(f,n);return d.map(e=>[dot(f,e),dot(l,e)])},copyVecArray=function(e){const n=Array(e.length);for(let d=0,a=e.length;d<a;d++)n[d]=e[d].slice(0);return n},mv3=(e,n)=>[e[0][0]*n[0]+e[0][1]*n[1]+e[0][2]*n[2],e[1][0]*n[0]+e[1][1]*n[1]+e[1][2]*n[2],e[2][0]*n[0]+e[2][1]*n[1]+e[2][2]*n[2]],mm3=(e,n)=>[[e[0][0]*n[0][0]+e[0][1]*n[1][0]+e[0][2]*n[2][0],e[0][0]*n[0][1]+e[0][1]*n[1][1]+e[0][2]*n[2][1],e[0][0]*n[0][2]+e[0][1]*n[1][2]+e[0][2]*n[2][2]],[e[1][0]*n[0][0]+e[1][1]*n[1][0]+e[1][2]*n[2][0],e[1][0]*n[0][1]+e[1][1]*n[1][1]+e[1][2]*n[2][1],e[1][0]*n[0][2]+e[1][1]*n[1][2]+e[1][2]*n[2][2]],[e[2][0]*n[0][0]+e[2][1]*n[1][0]+e[2][2]*n[2][0],e[2][0]*n[0][1]+e[2][1]*n[1][1]+e[2][2]*n[2][1],e[2][0]*n[0][2]+e[2][1]*n[1][2]+e[2][2]*n[2][2]]],eye3=[[1,0,0],[0,1,0],[0,0,1]],rotm=function(e,n,d){const a=[[cos(e),-1*sin(e),0],[sin(e),cos(e),0],[0,0,1]],f=[[cos(n),0,-1*sin(n)],[0,1,0],[sin(n),0,cos(n)]],l=[[1,0,0],[0,cos(d),-1*sin(d)],[0,sin(d),cos(d)]];return mm3(l,mm3(f,a))},vec_rotm=function(e,n,d,a){let f;e/=2;const l=sin(e),i=cos(e),t=l*l,u=mag([n,d,a]);if(0===u&&([n,d,a]=[0,0,1]),1!==u&&([n,d,a]=unit([n,d,a])),1===n&&0===d&&0===a)f=[[1,0,0],[0,1-2*t,2*l*i],[0,-2*l*i,1-2*t]];else if(0===n&&1===d&&0===a)f=[[1-2*t,0,-2*l*i],[0,1,0],[2*l*i,0,1-2*t]];else if(0===n&&0===d&&1===a)f=[[1-2*t,2*l*i,0],[-2*l*i,1-2*t,0],[0,0,1]];else{const e=n*n,u=d*d,c=a*a;f=[[1-2*(u+c)*t,2*(n*d*t+a*l*i),2*(n*a*t-d*l*i)],[2*(d*n*t-a*l*i),1-2*(c+e)*t,2*(d*a*t+n*l*i)],[2*(a*n*t+d*l*i),2*(a*d*t-n*l*i),1-2*(e+u)*t]]}return f},perspT=function(e,n,d,a,f){const l=(n*a-d)/(1-a),i=f*a/(1-a);return[i*e[0]/(e[2]+l),i*e[1]/(e[2]+l)]},invperspT=function(e,n,d,a,f,l,i,t){const u=(f*i-l)/(1-i),c=t*i/(1-i),s=e-d,g=n-a,o=c*c,p=u*u,h=s*s,r=g*g,m=(2*c*s*u+sqrt(4*o*h*p+4*h*(o+h+r)*(1-p)))/(2*(o+h+r)),y=c*g*u/(o+h+r)+g*sqrt(4*o*p+4*(o+h+r)*(1-p))/(2*(o+h+r)),x=sqrt(1-m*m-y*y);return[m,y,x]},getVec2VecRotM=function(e,n){const d=cross(e,n),a=acos(dot(e,n));return vec_rotm(-1*a,d[0],d[1],d[2])};function __range__(e,n,d){let a=[],f=e<n,l=d?f?n+1:n-1:n;for(let t=e;f?t<l:t>l;f?t++:t--)a.push(t);return a}const faceToEdges=function(e){const n=[];let[d]=e.slice(-1);for(let a of e)n.push([d,a]),d=a;return n},vertColors=function(e){const n=[];for(let d=0;d<e.face.length;d++){const a=e.face[d];for(let f of a)n[f]=e.face_class[d]}return n},rwb_palette=["#ff7777","#dddddd","#889999","#fff0e5","#aa3333","#ff0000","#ffffff","#aaaaaa"],hextofloats=function(e){let n;return"#"===e[0]&&(e=e.slice(1)),n=3===e.length?e.split("").map(e=>parseInt(e+e,16)/255):e.match(/.{2}/g).map(e=>parseInt(e,16)/255),n},PALETTE=rwb_palette,palette=function(e){return e<PALETTE.length?hextofloats(PALETTE[e]):hextofloats(PALETTE[PALETTE.length-1])},paintPolyhedron=function(e){e.face_class=[];const n={},d=function(e,n){const d=round(100*e);if(d in n)return n[d];else{const e=_.toArray(n).length;return n[d]=e,e}};for(var a of e.face){var f,l;"area"===COLOR_METHOD?(l=a.map(n=>e.xyz[n]),f=d(convexarea(l),n)):"signature"===COLOR_METHOD?(l=a.map(n=>e.xyz[n]),f=d(faceSignature(l),n)):f=a.length-3,e.face_class.push(f)}return console.log(_.toArray(n).length+" face classes"),e},sortfaces=function(e){const n=e.centers(),d=e.normals(),a=[0,0,(persp_z_max*persp_ratio-persp_z_min)/(1-persp_ratio)],f=_.zip(n,d,__range__(0,e.face.length,!1)).sort((e,n)=>e[0][2]-n[0][2]).map(e=>e[2]);e.face=f.map(n=>e.face[n]),e.face_class=f.map(n=>e.face_class[n])};class polyhedron{constructor(e,n,d){this.face=n||[],this.xyz=e||[],this.name=d||"null polyhedron"}data(){const e=this.face.length+this.xyz.length-2;return`${this.face.length} faces, ${e} edges, ${this.xyz.length} vertices`}moreData(){return`min. edge length ${this.minEdgeLength().toPrecision(2)}; min. face radius ${this.minFaceRadius().toPrecision(2)}`}edges(){let n;const d={},f=[],l=_.map(this.face,faceToEdges);for(let e of l)for(n of e){var i,t;n[0]<n[1]?[i,t]=n:[t,i]=n,d[i+"~"+t]=n}for(let e in d)n=d[e],f.push(n);return f}minEdgeLength(){let n=Number.MAX_VALUE;for(let d of this.edges()){const e=mag2(sub(this.xyz[d[0]],this.xyz[d[1]]));e<n&&(n=e)}return sqrt(n)}minFaceRadius(){let n=Number.MAX_VALUE;const d=this.face.length,a=this.centers();for(let l=0;l<d;l++){const d=a[l];for(let a of faceToEdges(this.face[l])){const e=linePointDist2(this.xyz[a[0]],this.xyz[a[1]],d);e<n&&(n=e)}}return sqrt(n)}centers(){const e=[];for(let n of this.face){let d=[0,0,0];for(let e of n)d=add(d,this.xyz[e]);e.push(mult(1/n.length,d))}return e}normals(){const e=[];for(let n of this.face)e.push(normal(n.map(e=>this.xyz[e])));return e}toOBJ(){let e,n,d="#Produced by polyH\xE9dronisme http://levskaya.github.com/polyhedronisme\n";d+=`group ${this.name}\n`,d+="#vertices\n";for(n of this.xyz)d+=`v ${n[0]} ${n[1]} ${n[2]}\n`;d+="#normal vector defs \n";for(e of this.face){const n=normal(e.map(e=>this.xyz[e]));d+=`vn ${n[0]} ${n[1]} ${n[2]}\n`}d+="#face defs \n";for(let a=0;a<this.face.length;a++){e=this.face[a],d+="f ";for(n of e)d+=`${n+1}//${a+1} `;d+="\n"}return d}toX3D(){let e;const n=.01;let d=`\
<?xml version="1.0" encoding ="UTF-8"?>
<X3D profile="Interchange" version="3.0">
<head>
<component name="Rendering" level="3"/>
<meta name="generator" content="Polyhedronisme"/>
<meta name="version" content="0.1.0"/>
</head>
<Scene>
<Shape>
<IndexedFaceSet normalPerVertex="false" coordIndex="\
`;for(let n of this.face){for(e of n)d+=`${e} `;d+="-1\n"}d+="\">\n",d+="<Color color=\"";for(let e of vertColors(this)){const n=palette(e);d+=`${n[0]} ${n[1]} ${n[2]} `}d+="\"/>",d+="<Coordinate point=\"";for(e of this.xyz)d+=`${e[0]*n} ${e[1]*n} ${e[2]*n} `;return d+="\"/>\n",d+=`\
</IndexedFaceSet>
</Shape>
</Scene>
</X3D>`,d}toVRML(){let e;const n=.01;let d=`\
#VRML V2.0 utf8
#Generated by Polyhedronisme
NavigationInfo {
	type [ "EXAMINE", "ANY" ]
}
Transform {
  scale 1 1 1
  translation 0 0 0
  children
  [
    Shape
    {
      geometry IndexedFaceSet
      {
        creaseAngle .5
        solid FALSE
        coord Coordinate
        {
          point
          [\
`;for(e of this.xyz)d+=`${e[0]*n} ${e[1]*n} ${e[2]*n},`;d=d.slice(0,-1),d+=`\
    ]
}
color Color
{
  color
  [\
`;for(let e of this.face_class){const n=palette(e);d+=`${n[0]} ${n[1]} ${n[2]} ,`}d=d.slice(0,-1),d+=`\
  ]
}
colorPerVertex FALSE
coordIndex
[\
`;for(let n of this.face){for(e of n)d+=`${e}, `;d+="-1,"}return d=d.slice(0,-1),d+=`\
          ]
      }
      appearance Appearance
      {
        material Material
        {
	       ambientIntensity 0.2
	       diffuseColor 0.9 0.9 0.9
	       specularColor .1 .1 .1
	       shininess .5
        }
      }
    }
  ]
}\
`,d}}const tetrahedron=function(){const e=new polyhedron;return e.name="T",e.face=[[0,1,2],[0,2,3],[0,3,1],[1,3,2]],e.xyz=[[1,1,1],[1,-1,-1],[-1,1,-1],[-1,-1,1]],e},octahedron=function(){const e=new polyhedron;return e.name="O",e.face=[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]],e.xyz=[[0,0,1.414],[1.414,0,0],[0,1.414,0],[-1.414,0,0],[0,-1.414,0],[0,0,-1.414]],e},cube=function(){const e=new polyhedron;return e.name="C",e.face=[[3,0,1,2],[3,4,5,0],[0,5,6,1],[1,6,7,2],[2,7,4,3],[5,4,7,6]],e.xyz=[[.707,.707,.707],[-.707,.707,.707],[-.707,-.707,.707],[.707,-.707,.707],[.707,-.707,-.707],[.707,.707,-.707],[-.707,.707,-.707],[-.707,-.707,-.707]],e},icosahedron=function(){const e=new polyhedron;return e.name="I",e.face=[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]],e.xyz=[[0,0,1.176],[1.051,0,.526],[.324,1,.525],[-.851,.618,.526],[-.851,-.618,.526],[.325,-1,.526],[.851,.618,-.526],[.851,-.618,-.526],[-.325,1,-.526],[-1.051,0,-.526],[-.325,-1,-.526],[0,0,-1.176]],e},dodecahedron=function(){const e=new polyhedron;return e.name="D",e.face=[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]],e.xyz=[[0,0,1.07047],[.713644,0,.797878],[-.356822,.618,.797878],[-.356822,-.618,.797878],[.797878,.618034,.356822],[.797878,-.618,.356822],[-.934172,.381966,.356822],[.136294,1,.356822],[.136294,-1,.356822],[-.934172,-.381966,.356822],[.934172,.381966,-.356822],[.934172,-.381966,-.356822],[-.797878,.618,-.356822],[-.136294,1,-.356822],[-.136294,-1,-.356822],[-.797878,-.618034,-.356822],[.356822,.618,-.797878],[.356822,-.618,-.797878],[-.713644,0,-.797878],[0,0,-1.07047]],e},prism=function(e){var n=Math.sin;let d;const a=2*PI/e,f=n(a/2);let l=new polyhedron;for(l.name=`P${e}`,d=0;d<e;d++)l.xyz.push([-cos(d*a),-sin(d*a),-f]);for(d=0;d<e;d++)l.xyz.push([-cos(d*a),-sin(d*a),f]);for(l.face.push(__range__(e-1,0,!0)),l.face.push(__range__(e,2*e,!1)),d=0;d<e;d++)l.face.push([d,(d+1)%e,(d+1)%e+e,d+e]);return l=adjustXYZ(l,1),l},antiprism=function(e){let n;const d=2*PI/e;let a=sqrt(1-4/(4+2*cos(d/2)-2*cos(d))),l=sqrt(1-a*a);const t=sqrt(a*a+pow(l*cos(d/2),2));l=-l/t,a=-a/t;let f=new polyhedron;for(f.name=`A${e}`,n=0;n<e;n++)f.xyz.push([l*cos(n*d),l*sin(n*d),a]);for(n=0;n<e;n++)f.xyz.push([l*cos((n+.5)*d),l*sin((n+.5)*d),-a]);for(f.face.push(__range__(e-1,0,!0)),f.face.push(__range__(e,2*e-1,!0)),n=0;n<=e-1;n++)f.face.push([n,(n+1)%e,n+e]),f.face.push([n,n+e,(e+n-1)%e+e]);return f=adjustXYZ(f,1),f},pyramid=function(e){let n;const d=2*PI/e;let a=new polyhedron;for(a.name=`Y${e}`,n=0;n<e;n++)a.xyz.push([-cos(n*d),-sin(n*d),-.2]);for(a.xyz.push([0,0,1]),a.face.push(__range__(e-1,0,!0)),n=0;n<e;n++)a.face.push([n,(n+1)%e,e]);return a=canonicalXYZ(a,3),a};class polyflag{constructor(){this.flags={},this.verts={},this.xyzs={}}newV(e,n){this.verts[e]===void 0&&(this.verts[e]=0,this.xyzs[e]=n)}newFlag(e,n,d){this.flags[e]===void 0&&(this.flags[e]={}),this.flags[e][n]=d}topoly(){let e,n;const d=new polyhedron;let a=0;for(e in this.verts)n=this.verts[e],d.xyz[a]=this.xyzs[e],this.verts[e]=a,a++;for(e in a=0,this.flags){var l;const i=this.flags[e];for(let e in d.face[a]=[],i){n=i[e],l=n;break}n=l,d.face[a].push(this.verts[n]),n=this.flags[e][n];for(let f=0;n!==l;)if(d.face[a].push(this.verts[n]),n=this.flags[e][n],f++,1e3<f){console.log("Bad flag spec, have a neverending face:",e,this.flags[e]);break}a++}return d.name="unknown polyhedron",d}}const kisN=function(e,d,a){let l;d||(d=0),a||(a=.1),console.log(`Taking kis of ${0===d?"":d}-sided faces of ${e.name}...`);const t=new polyflag;for(l=0;l<e.xyz.length;l++){const n=e.xyz[l];t.newV(`v${l}`,n)}const u=e.normals(),c=e.centers();let s=!1;for(l=0;l<e.face.length;l++){const n=e.face[l];let f=`v${n[n.length-1]}`;for(let e of n){const i=`v${e}`;if(n.length===d||0===d){s=!0;const e=`apex${l}`,n=`${l}${f}`;t.newV(e,add(c[l],mult(a,u[l]))),t.newFlag(n,f,i),t.newFlag(n,i,e),t.newFlag(n,e,f)}else t.newFlag(`${l}`,f,i);f=i}}s||console.log(`No ${d}-fold components were found.`);const g=t.topoly();return g.name=`k${0===d?"":d}${e.name}`,g},ambo=function(e){console.log(`Taking ambo of ${e.name}...`);const n=function(e,n){return e<n?e+"_"+n:n+"_"+e},d=new polyflag;for(let a=0;a<e.face.length;a++){const l=e.face[a];let[f,i]=Array.from(l.slice(-2));for(let t of l)f<i&&d.newV(n(f,i),midpoint(e.xyz[f],e.xyz[i])),d.newFlag(`orig${a}`,n(f,i),n(i,t)),d.newFlag(`dual${i}`,n(i,t),n(f,i)),[f,i]=Array.from([i,t])}const a=d.topoly();return a.name=`a${e.name}`,a},gyro=function(e){let n,d,a;console.log(`Taking gyro of ${e.name}...`);const l=new polyflag;for(d=0;d<e.xyz.length;d++)a=e.xyz[d],l.newV(`v${d}`,unit(a));const t=e.centers();for(d=0;d<e.face.length;d++)n=e.face[d],l.newV(`center${d}`,unit(t[d]));for(d=0;d<e.face.length;d++){n=e.face[d];let[f,i]=Array.from(n.slice(-2));for(let t=0;t<n.length;t++){a=n[t];const u=a;l.newV(f+"~"+i,oneThird(e.xyz[f],e.xyz[i]));const c=d+"f"+f;l.newFlag(c,`center${d}`,f+"~"+i),l.newFlag(c,f+"~"+i,i+"~"+f),l.newFlag(c,i+"~"+f,`v${i}`),l.newFlag(c,`v${i}`,i+"~"+u),l.newFlag(c,i+"~"+u,`center${d}`),[f,i]=Array.from([i,u])}}const u=l.topoly();return u.name=`g${e.name}`,u},propellor=function(e){let n,d;console.log(`Taking propellor of ${e.name}...`);const a=new polyflag;for(n=0;n<e.xyz.length;n++)d=e.xyz[n],a.newV(`v${n}`,unit(d));for(n=0;n<e.face.length;n++){const l=e.face[n];let[f,i]=Array.from(l.slice(-2));for(d of l){const l=`${d}`;a.newV(f+"~"+i,oneThird(e.xyz[f],e.xyz[i]));const t=`${n}f${i}`;a.newFlag(`v${n}`,f+"~"+i,i+"~"+l),a.newFlag(t,f+"~"+i,i+"~"+f),a.newFlag(t,i+"~"+f,`v${i}`),a.newFlag(t,`v${i}`,i+"~"+l),a.newFlag(t,i+"~"+l,f+"~"+i),[f,i]=Array.from([i,l])}}const f=a.topoly();return f.name=`p${e.name}`,f},reflect=function(e){let n;for(console.log(`Taking reflection of ${e.name}...`),n=0;n<=e.xyz.length-1;n++)e.xyz[n]=mult(-1,e.xyz[n]);for(n=0;n<=e.face.length-1;n++)e.face[n]=e.face[n].reverse();return e.name=`r${e.name}`,e},dual=function(e){let n,d,a,l;console.log(`Taking dual of ${e.name}...`);const t=new polyflag,u=[];for(d=0;d<=e.xyz.length-1;d++)u[d]={};for(d=0;d<e.face.length;d++){n=e.face[d],a=n[n.length-1];for(l of n)u[a][`v${l}`]=`${d}`,a=l}const c=e.centers();for(d=0;d<=e.face.length-1;d++)t.newV(`${d}`,c[d]);for(d=0;d<e.face.length;d++){n=e.face[d],a=n[n.length-1];for(l of n)t.newFlag(a,u[l][`v${a}`],`${d}`),a=l}const s=t.topoly(),g=[];for(n of s.face){const d=intersect(e.face[n[0]],e.face[n[1]],e.face[n[2]]);g[d]=n}return s.face=g,s.name="d"===e.name[0]?e.name.slice(1):`d${e.name}`,s},chamfer=function(e,n){console.log(`Taking chamfer of ${e.name}...`),n||(n=.5);const d=new polyflag,a=e.normals();for(let l=0;l<e.face.length;l++){const i=e.face[l];let f=i[i.length-1],t=l+"_"+f;for(let u of i){d.newV(u,mult(1+n,e.xyz[u]));const i=l+"_"+u;d.newV(i,add(e.xyz[u],mult(1.5*n,a[l]))),d.newFlag(`orig${l}`,t,i);const c=f<u?`hex${f}_${u}`:`hex${u}_${f}`;d.newFlag(c,u,i),d.newFlag(c,i,t),d.newFlag(c,t,f),f=u,t=i}}const f=d.topoly();return f.name=`c${e.name}`,f},whirl=function(e,d){let a,l;console.log(`Taking whirl of ${e.name}...`),d||(d=0);const t=new polyflag;for(a=0;a<e.xyz.length;a++)l=e.xyz[a],t.newV(`v${a}`,unit(l));const u=e.centers();for(a=0;a<e.face.length;a++){const n=e.face[a];let[d,f]=Array.from(n.slice(-2));for(let i=0;i<n.length;i++){l=n[i];const c=l,s=oneThird(e.xyz[d],e.xyz[f]);t.newV(d+"~"+f,s);const g=`center${a}~${d}`,o=`center${a}~${f}`;t.newV(g,unit(oneThird(u[a],s)));const p=a+"f"+d;t.newFlag(p,g,d+"~"+f),t.newFlag(p,d+"~"+f,f+"~"+d),t.newFlag(p,f+"~"+d,`v${f}`),t.newFlag(p,`v${f}`,f+"~"+c),t.newFlag(p,f+"~"+c,o),t.newFlag(p,o,g),t.newFlag(`c${a}`,g,o),[d,f]=Array.from([f,c])}}const c=t.topoly();return c.name=`w${e.name}`,c},insetN=function(e,d,a,l){let t,u,c;d||(d=0),a||(a=.5),l||(l=-.2),console.log(`Taking inset of ${0===d?"":d}-sided faces of ${e.name}...`);const s=new polyflag;for(u=0;u<e.xyz.length;u++){const n=e.xyz[u];s.newV(`v${u}`,n)}const g=e.normals(),o=e.centers();for(u=0;u<e.face.length;u++)if(t=e.face[u],t.length===d||0===d)for(c of t)s.newV(`f${u}v${c}`,add(tween(e.xyz[c],o[u],a),mult(l,g[u])));let p=!1;for(u=0;u<e.face.length;u++){t=e.face[u];let n=`v${t[t.length-1]}`;for(c of t){const e=`v${c}`;if(t.length===d||0===d){p=!0;const d=u+n;s.newFlag(d,n,e),s.newFlag(d,e,`f${u}${e}`),s.newFlag(d,`f${u}${e}`,`f${u}${n}`),s.newFlag(d,`f${u}${n}`,n),s.newFlag(`ex${u}`,`f${u}${n}`,`f${u}${e}`)}else s.newFlag(u,n,e);n=e}}p||console.log(`No ${d}-fold components were found.`);const h=s.topoly();return h.name=`n${0===d?"":d}${e.name}`,h},extrudeN=function(e,d){let a,l,t;d||(d=0),console.log(`Taking extrusion of ${0===d?"":d}-sided faces of ${e.name}...`);const u=new polyflag;for(l=0;l<e.xyz.length;l++){const n=e.xyz[l];u.newV(`v${l}`,n)}const c=e.normals(),s=e.centers();for(l=0;l<e.face.length;l++)if(a=e.face[l],a.length===d||0===d)for(t of a)u.newV(`f${l}v${t}`,add(e.xyz[t],mult(.3,c[l])));let g=!1;for(l=0;l<e.face.length;l++){a=e.face[l];let n=`v${a[a.length-1]}`;for(t of a){const e=`v${t}`;a.length===d||0===d?(g=!0,u.newFlag(l+n,n,e),u.newFlag(l+n,e,`f${l}${e}`),u.newFlag(l+n,`f${l}${e}`,`f${l}${n}`),u.newFlag(l+n,`f${l}${n}`,n),u.newFlag(`ex${l}`,`f${l}${n}`,`f${l}${e}`)):u.newFlag(l,n,e),n=e}}g||console.log(`No ${d}-fold components were found.`);const o=u.topoly();return o.name=`x${0===d?"":d}${e.name}`,o},hollow=function(e,d,a,l){let t,u,c;d||(d=0),a||(a=.5),l||(l=.2),console.log(`Skeletonizing ${0===d?"":d}-sided faces of ${e.name}...`);const s=dual(e).normals(),g=e.normals(),o=e.centers(),h=new polyflag;for(u=0;u<e.xyz.length;u++){const n=e.xyz[u];h.newV(`v${u}`,n),h.newV(`downv${u}`,add(n,mult(-1*l,s[u])))}for(u=0;u<e.face.length;u++){t=e.face[u];for(c of t)h.newV(`fin${u}v${c}`,tween(e.xyz[c],o[u],a)),h.newV(`findown${u}v${c}`,add(tween(e.xyz[c],o[u],a),mult(-1*l,g[u])))}for(u=0;u<e.face.length;u++){t=e.face[u];let n=`v${t[t.length-1]}`;for(c of t){const e=`v${c}`;let d=u+n;h.newFlag(d,n,e),h.newFlag(d,e,`fin${u}${e}`),h.newFlag(d,`fin${u}${e}`,`fin${u}${n}`),h.newFlag(d,`fin${u}${n}`,n),d=`sides${u}${n}`,h.newFlag(d,`fin${u}${n}`,`fin${u}${e}`),h.newFlag(d,`fin${u}${e}`,`findown${u}${e}`),h.newFlag(d,`findown${u}${e}`,`findown${u}${n}`),h.newFlag(d,`findown${u}${n}`,`fin${u}${n}`),d=`bottom${u}${n}`,h.newFlag(d,`down${e}`,`down${n}`),h.newFlag(d,`down${n}`,`findown${u}${n}`),h.newFlag(d,`findown${u}${n}`,`findown${u}${e}`),h.newFlag(d,`findown${u}${e}`,`down${e}`),n=e}}const r=h.topoly();return r.name=`h${e.name}`,r},stellaN=function(e){let n;console.log(`Taking stella of ${e.name}...`);const d=e.centers(),a=new polyflag;for(n=0;n<e.xyz.length;n++){const d=e.xyz[n];a.newV(`v${n}`,d)}for(n=0;n<e.face.length;n++){const l=e.face[n];let f=`v${l[l.length-2]}`,i=`v${l[l.length-1]}`,t=e.xyz[l[l.length-2]],u=e.xyz[l[l.length-1]];for(let c of l){const l=`v${c}`,s=e.xyz[c],g=f+"~"+i,o=i+"~"+f,p=i+"~"+l;a.newV(g,midpoint(midpoint(t,u),d[n])),a.newFlag(`in${n}`,g,p),a.newFlag(`f${n}${i}`,p,g),a.newFlag(`f${n}${i}`,g,i),a.newFlag(`f${n}${i}`,i,p),a.newFlag(`f${g}`,f,o),a.newFlag(`f${g}`,o,g),a.newFlag(`f${g}`,g,f),[f,i]=Array.from([i,l]),[t,u]=Array.from([u,s])}}const f=a.topoly();return f.name=`l${e.name}`,f},tangentify=function(e,n){const d=copyVecArray(e);for(let a of n){const e=tangentPoint(d[a[0]],d[a[1]]),n=mult(1*.1/2*(1-sqrt(dot(e,e))),e);d[a[0]]=add(d[a[0]],n),d[a[1]]=add(d[a[1]],n)}return d},recenter=function(e,n){const d=n.map(([n,d])=>tangentPoint(e[n],e[d]));let a=[0,0,0];for(let f of d)a=add(a,f);return a=mult(1/n.length,a),_.map(e,e=>sub(e,a))},rescale=function(e){const n=_.max(_.map(e,e=>mag(e))),d=1/n;return _.map(e,e=>[d*e[0],d*e[1],d*e[2]])},planarize=function(e,n){let d;const a=copyVecArray(e);for(var l of n){const f=l.map(n=>e[n]);let i=normal(f);const n=calcCentroid(f);0>dot(i,n)&&(i=mult(-1,i));for(d of l)a[d]=add(a[d],mult(dot(mult(.1,i),sub(n,e[d])),i))}return a},canonicalize=function(e,n){n||(n=1),console.log(`Canonicalizing ${e.name}...`);const d=e.face,a=e.edges();let f=e.xyz,l=1;for(let t=0;t<=n;t++){const e=copyVecArray(f);if(f=tangentify(f,a),f=recenter(f,a),f=planarize(f,d),l=_.max(_.map(_.zip(f,e),([e,n])=>mag(sub(e,n)))),1e-8>l)break}console.log(`[canonicalization done, last |deltaV|=${l}]`);const i=new polyhedron(f,e.face,e.name);return console.log("canonicalize",i),i},reciprocalC=function(e){const n=e.centers();for(let d of n)d=mult(1/dot(d,d),d);return n},reciprocalN=function(e){const n=[];for(let d of e.face){let a=[0,0,0],f=[0,0,0],l=0,[i,t]=d.slice(-2);for(let n of d)a=add(a,e.xyz[n]),f=add(f,orthogonal(e.xyz[i],e.xyz[t],e.xyz[n])),l+=edgeDist(e.xyz[i],e.xyz[t]),[i,t]=[t,n];a=mult(1/d.length,a),f=unit(f),l/=d.length;const u=reciprocal(mult(dot(a,f),f));n.push(mult((1+l)/2,u))}return n},canonicalXYZ=function(e,n){n||(n=1);const d=dual(e);console.log(`Pseudo-canonicalizing ${e.name}...`);for(let a=0,f=n;a<f;a++)d.xyz=reciprocalN(e),e.xyz=reciprocalN(d);return new polyhedron(e.xyz,e.face,e.name)},adjustXYZ=function(e,n){n||(n=1);const d=dual(e);console.log(`Planarizing ${e.name}...`);for(let a=0,f=n;a<f;a++)d.xyz=reciprocalC(e),e.xyz=reciprocalC(d);return new polyhedron(e.xyz,e.face,e.name)};function __range__(e,n,d){let a=[],f=e<n,l=d?f?n+1:n-1:n;for(let t=e;f?t<l:t>l;f?t++:t--)a.push(t);return a}const getDiagonals=function(e){let d,a;const f=[],l=[];let i=e.length;const t=(e,n)=>(e||n)&&!(e&&n),u=(e,n,d)=>(n[0]-e[0])*(d[1]-e[1])-(d[0]-e[0])*(n[1]-e[1]),c=(e,n,d)=>0<u(e,n,d),s=(e,n,d)=>0<=u(e,n,d),g=(e,n,d)=>0===u(e,n,d),o=function(e,n,d){return!g(e,n,d)&&(e[0]===n[0]?e[1]<=d[1]&&d[1]<=n[1]||e[1]>=d[1]&&d[1]>=n[1]:e[0]<=d[0]&&d[0]<=n[0]||e[0]>=d[0]&&d[0]>=n[0])},p=function(e,n,d,a){return!(g(e,n,d)||g(e,n,a)||g(d,a,e)||g(d,a,n))&&t(c(e,n,d),c(e,n,a))&&t(c(d,a,e),c(d,a,n))},h=function(n,d){const a=(n+1+i)%i,f=(n-1+i)%i;return s(e[n],e[a],e[f])?c(e[n],e[d],e[f])&&c(e[d],e[n],e[a]):!(s(e[n],e[d],e[a])&&s(e[d],e[n],e[f]))},r=function(n,d){for(let a=0;;){const f=(a+1+i)%i;if(a!==n&&f!==n&&a!==d&&f!==d&&p(e[n],e[d],e[a],e[f]))return!1;if(a=(a+1+i)%i,0===a)break}return!0},m=(e,n)=>h(e,n)&&h(n,e)&&r(e,n);let y=0;for(;a=(y+1+i)%i,d=(y-1+i)%i,l[y]=m(d,a),y=(y+1+i)%i,0!=y;);let x=__range__(0,i-1,!0),w=i,v=999,F=0;for(;0<v&&3<w;){v-=1,a=F;for(let n=999;;){n-=1;let t=!1;if(l[a]){let n=(a+1+i)%i,u=(n+1+i)%i;y=(a-1+i)%i,d=(y-1+i)%i,f.push([x[y],x[n]]),l[y]=m(d,n),l[n]=m(y,u),e=e.slice(0,+a+1||void 0).concat(e.slice(n)),x=x.slice(0,+a+1||void 0).concat(x.slice(n)),d>a&&(d-=1),y>a&&(y-=1),n>a&&(n-=1),u>a&&(u-=1),i--,F=n,w--,t=!0}if(a=(a+1+i)%i,0>=n||!!t||a===F)break}}return f},triEq=function(e,n){return!((e[0]!==n[0]||e[1]!==n[1]||e[2]!==n[2])&&(e[0]!==n[1]||e[1]!==n[2]||e[2]!==n[0])&&(e[0]!==n[2]||e[1]!==n[0]||e[2]!==n[1]))},diagsToTris=function(e,n){let a;const f=[],l=[];for(let[d,a]of __range__(0,e.length-1,!0).map(n=>[n,(n+1)%e.length]))f[d]=[a],l[a]=[d];for(a of n)f[a[0]].push(a[1]),f[a[1]].push(a[0]),l[a[0]].push(a[1]),l[a[1]].push(a[0]);const i=[];for(a of n){var t,u;for(t of f[a[1]])for(u of l[a[0]])t===u&&i.push([a[0],a[1],t]);for(t of f[a[0]])for(u of l[a[1]])t===u&&i.push([a[1],a[0],t])}const c=[i.pop()];for(let d of i){let e=!1;for(let n of c)if(triEq(d,n)){e=!0;break}e||c.push(d)}return c},triangulate=function(e,n){n=n||!1,console.log(`Triangulating faces of ${e.name}...`);const d=new polyhedron;d.xyz=clone(e.xyz),d.face_class=[];for(let a=0;a<e.face.length;a++){const l=e.face[a];if(3<l.length){const f=project2dface(l.map(n=>e.xyz[n])),i=getDiagonals(f),t=diagsToTris(l,i);for(let f=0;f<t.length;f++){const i=t[f];d.face.push([l[i[0]],l[i[1]],l[i[2]]]),n&&d.face_class.push(e.face_class[a])}}else d.face.push([l[0],l[1],l[2]]),n&&d.face_class.push(e.face_class[a])}return d.name=e.name,d},topolog=function(e){let n="";for(let d of e.face){for(let e of d)n+=`${e}->`;n+="\n"}console.log(n)},testrig=function(){const e=["T","O","C","I","D","P3","P4","A4","A5","Y3","Y4"],n=["k","a","g","p","d","r","e","b","o","m","t","j","s","p","c","w","l","n","x","z","h"];console.log("===== Test Basic Ops =====");for(let d of n){console.log(`Operator ${d}`);for(let n of e)console.log(d+n+":",newgeneratePoly(d+n))}console.log("===== Done Testing Basic Ops =====")},PEG_parser_spec=`\
/* series of opspecs */
start  = opspec+

/* opspec one of:
 A  - single letter
 A3 - single letter and float
 B(5,4.3,3) - function call format w. float args
*/
opspec =
   let:opcode args:opargs {return {"op":let,"args":args};}
/ let:opcode float:float     {return {"op":let,"args":[float]};}
/ let:opcode                     {return {"op":let,"args":[]};}

/*
parentheses surrounding comma-delimited list of floats i.e.
( 1 , 3.2, 4 ) or (1) or (2,3)
*/
opargs = "("
           num:( float:float ","? {return float} )+
         ")" {return num;}

/* just a letter */
opcode = op:[a-zA-Z] {return op;}

/* standard numerical types */
int   = digits:[0-9-]+   { return parseInt(digits.join(""), 10);  }
float = digits:[0-9.-]+  { return parseFloat(digits.join(""), 10); }\
`,op_parser=PEG.buildParser(PEG_parser_spec),dispatch=function(e,n){return e.apply(this,n||[])},basemap={T:tetrahedron,O:octahedron,C:cube,I:icosahedron,D:dodecahedron,P:prism,A:antiprism,Y:pyramid},opmap={d:dual,k:kisN,a:ambo,g:gyro,p:propellor,r:reflect,h:hollow,c:chamfer,w:whirl,n:insetN,x:extrudeN,l:stellaN,z:triangulate,K:canonicalXYZ,C:canonicalize,A:adjustXYZ},specreplacements=[[/e/g,"aa"],[/b/g,"ta"],[/o/g,"jj"],[/m/g,"kj"],[/t(\d*)/g,"dk$1d"],[/j/g,"dad"],[/s/g,"dgd"],[/dd/g,""],[/ad/g,"a"],[/gd/g,"g"],[/aO/g,"aC"],[/aI/g,"aD"],[/gO/g,"gC"],[/gI/g,"gD"]],getOps=function(e){let n=e;for(let[d,a]of specreplacements)n=n.replace(d,a);return console.log(`${e} executed as ${n}`),n},newgeneratePoly=function(e){const n=getOps(e),d=op_parser.parse(n).reverse();let a=d.shift();const f=basemap[a.op],l=a.args;let i=dispatch(f,l);for(a of d){const e=opmap[a.op],n=[i].concat(a.args);i=dispatch(e,n)}return i.xyz=recenter(i.xyz,i.edges()),i.xyz=rescale(i.xyz),i=paintPolyhedron(i),i};let ctx={},globPolys={};const CANVAS_WIDTH=500,CANVAS_HEIGHT=400;let globRotM=clone(eye3),globLastRotM=clone(eye3),perspective_scale=800;const persp_z_max=5,persp_z_min=0,persp_ratio=.8,_2d_x_offset=250,_2d_y_offset=CANVAS_HEIGHT/2,BG_CLEAR=!0,BG_COLOR="rgba(255,255,255,1.0)",COLOR_METHOD="signature",ctx_linewidth=.5;let PaintMode="fillstroke",MOUSEDOWN=!1,LastMouseX=0,LastMouseY=0,LastSphVec=[1,0,0];const DEFAULT_RECIPES=["C2dakD","oC20kkkT","kn4C40A0dA4","opD","lT","lK5oC","knD","dn6x4K5bT","oox4P7","n18n18n9n9n9soxY9"],saveText=function(e,n){const d=new Blob([e],{type:`text/plain;charset=${document.characterSet}`});saveAs(d,n)},parseurl=function(){let n;const f={},l=/\+/g,a=/([^&=]+)=?([^&]*)/g,i=e=>decodeURIComponent(e.replace(l," ")),d=window.location.search.substring(1);for(;n=a.exec(d);)f[i(n[1])]=i(n[2]);return f},setlink=function(){const e=$("#spec").val().split(/\s+/g).slice(0,2);let n=location.protocol+"//"+location.host+location.pathname;n+=`?recipe=${encodeURIComponent(e[0])}`,PALETTE!==rwb_palette&&(n+=`&palette=${encodeURIComponent(PALETTE.reduce((e,n)=>e+" "+n))}`),$("#link").attr("href",n)},init=function(){const e=$("#poly");e.width(CANVAS_WIDTH),e.height(CANVAS_HEIGHT),ctx=e[0].getContext("2d"),ctx.lineWidth=ctx_linewidth,BG_CLEAR?ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT):(ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT),ctx.fillStyle=BG_COLOR,ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT));const n=$("#expandcollapse");n.click(function(){/minus/.test(n.attr("src"))?($("#morestats").hide(),n.attr("src","media/plus.png")):($("#morestats").show(),n.attr("src","media/minus.png"))})},clear=function(){BG_CLEAR?ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT):(ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT),ctx.fillStyle=BG_COLOR,ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT))},drawpoly=function(e,n){let d;n||(n=[3,3,3]);const a=_.map(e.xyz,e=>e);e.xyz=_.map(e.xyz,e=>mv3(globRotM,e)),sortfaces(e);for(let a=0;a<e.face.length;a++){var f=e.face[a];ctx.beginPath();const l=f[f.length-1];let[i,t]=perspT(add(n,e.xyz[l]),persp_z_max,persp_z_min,persp_ratio,perspective_scale);ctx.moveTo(i+_2d_x_offset,t+_2d_y_offset);for(d of f)[i,t]=perspT(add(n,e.xyz[d]),persp_z_max,persp_z_min,persp_ratio,perspective_scale),ctx.lineTo(i+_2d_x_offset,t+_2d_y_offset);let u=palette(e.face_class[a]);const c=f.map(n=>e.xyz[n]),s=dot(normal(c),unit([1,-1,0]));u=mult(.7*(s/2+.5)+.3,u),("fill"==PaintMode||"fillstroke"==PaintMode)&&(ctx.fillStyle=`rgba(${round(255*u[0])}, ${round(255*u[1])}, ${round(255*u[2])}, ${1})`,ctx.fill(),ctx.strokeStyle=`rgba(${round(255*u[0])}, ${round(255*u[1])}, ${round(255*u[2])}, ${1})`,ctx.stroke()),"fillstroke"==PaintMode&&(ctx.fillStyle=`rgba(${round(255*u[0])}, ${round(255*u[1])}, ${round(255*u[2])}, ${1})`,ctx.fill(),ctx.strokeStyle="rgba(0,0,0,0.3)",ctx.stroke()),"stroke"==PaintMode&&(ctx.strokeStyle="rgba(0,0,0,0.8)",ctx.stroke())}e.xyz=a},drawShape=function(){clear(),globPolys.map((e,n)=>drawpoly(e,[0+3*n,0,3]))},updateStats=function(){for(let e=0;e<globPolys.length;e++){const n=globPolys[e];$("#basicstats").text(n.data()),$("#morestats").text(n.moreData())}};$(function(){init();const e=parseurl();"recipe"in e?(specs=[e.recipe],$("#spec").val(specs)):(specs=[randomchoice(DEFAULT_RECIPES)],$("#spec").val(specs),setlink()),"palette"in e&&(PALETTE=e.palette.split(/\s+/g),setlink()),$("#palette").val(PALETTE.reduce((e,n)=>e+" "+n)),globPolys=_.map(specs,e=>newgeneratePoly(e)),updateStats(),drawShape(),$("#spec").change(function(){specs=$("#spec").val().split(/\s+/g).slice(0,2),globPolys=_.map(specs,e=>newgeneratePoly(e)),updateStats(),setlink(),drawShape()}),$("#palette").change(function(){PALETTE=$(this).val().split(/\s+/g),setlink(),drawShape()}),$("#poly").mousewheel(function(n,e){n.preventDefault(),perspective_scale*=(10+e)/10,drawShape()}),$("#poly").mousedown(function(n){n.preventDefault(),MOUSEDOWN=!0,LastMouseX=n.clientX-$(this).offset().left,LastMouseY=n.clientY-($(this).offset().top-$(window).scrollTop());const e=invperspT(LastMouseX,LastMouseY,_2d_x_offset,_2d_y_offset,persp_z_max,persp_z_min,persp_ratio,perspective_scale);0==0*(e[0]*e[1]*e[2])&&(LastSphVec=e),globLastRotM=clone(globRotM)}),$("#poly").mouseup(function(n){n.preventDefault(),MOUSEDOWN=!1}),$("#poly").mouseleave(function(n){n.preventDefault(),MOUSEDOWN=!1}),$("#poly").mousemove(function(n){if(n.preventDefault(),MOUSEDOWN){const e=n.clientX-$(this).offset().left,d=n.clientY-($(this).offset().top-$(window).scrollTop()),a=invperspT(e,d,_2d_x_offset,_2d_y_offset,persp_z_max,persp_z_min,persp_ratio,perspective_scale);0==0*(a[0]*a[1]*a[2])&&0==0*(LastSphVec[0]*LastSphVec[1]*LastSphVec[2])&&(globRotM=mm3(getVec2VecRotM(LastSphVec,a),globLastRotM)),drawShape()}}),$("#strokeonly").click(function(){PaintMode="stroke",drawShape()}),$("#fillonly").click(function(){PaintMode="fill",drawShape()}),$("#fillandstroke").click(function(){PaintMode="fillstroke",drawShape()}),$("#siderot").click(function(){globRotM=vec_rotm(PI/2,0,1,0),drawShape()}),$("#toprot").click(function(){globRotM=vec_rotm(PI/2,1,0,0),drawShape()}),$("#frontrot").click(function(){globRotM=rotm(0,0,0),drawShape()}),$("#pngsavebutton").click(function(){const e=$("#poly")[0],n=$("#spec").val().split(/\s+/g)[0],d=`polyhedronisme-${n.replace(/\([^\)]+\)/g,"")}.png`;e.toBlobHD(e=>saveAs(e,d))}),$("#objsavebutton").click(function(){const e=globPolys[0].toOBJ(),n=$("#spec").val().split(/\s+/g)[0],d=`polyhedronisme-${n.replace(/\([^\)]+\)/g,"")}.obj`;saveText(e,d)}),$("#x3dsavebutton").click(function(){const e=triangulate(globPolys[0],!0),n=e.toVRML(),d=$("#spec").val().split(/\s+/g)[0],a=`polyhedronisme-${d.replace(/\([^\)]+\)/g,"")}.wrl`;saveText(n,a)})});