const{random,round,floor,sqrt,sin,cos,tan,asin,acos,atan,abs,PI,LN10,pow,log}=Math,log10=e=>log(e)/LN10,sigfigs=function(e,n){const d=pow(10,log10(e)-floor(log10(e)));return`${round(d*(n-1))}`};var clone=function(e){if(null==e||"object"!=typeof e)return e;const n=new e.constructor;for(let d in e)n[d]=clone(e[d]);return n};const randomchoice=function(e){const d=floor(random()*e.length);return e[d]},mult=(e,n)=>[e*n[0],e*n[1],e*n[2]],_mult=(e,n)=>[e[0]*n[0],e[1]*n[1],e[2]*n[2]],add=(e,n)=>[e[0]+n[0],e[1]+n[1],e[2]+n[2]],sub=(e,n)=>[e[0]-n[0],e[1]-n[1],e[2]-n[2]],dot=(e,n)=>e[0]*n[0]+e[1]*n[1]+e[2]*n[2],cross=(e,n)=>[e[1]*n[2]-e[2]*n[1],e[2]*n[0]-e[0]*n[2],e[0]*n[1]-e[1]*n[0]],mag=e=>sqrt(dot(e,e)),mag2=e=>dot(e,e),unit=e=>mult(1/sqrt(mag2(e)),e),midpoint=(e,n)=>mult(1/2,add(e,n)),tween=(e,n,d)=>[(1-d)*e[0]+d*n[0],(1-d)*e[1]+d*n[1],(1-d)*e[2]+d*n[2]],oneThird=(e,n)=>tween(e,n,1/3),reciprocal=e=>mult(1/mag2(e),e),tangentPoint=function(e,n){const a=sub(n,e);return sub(e,mult(dot(a,e)/mag2(a),a))},edgeDist=(e,n)=>sqrt(mag2(tangentPoint(e,n))),linePointDist2=function(e,n,d){let a;const f=sub(n,e),l=sub(e,d),i=mag2(f),u=-dot(l,f)/i;return 0>=u?mag2(l):(1<=u&&(a=mag2(sub(n,d))),a=mag2(cross(f,l))/i,a)},orthogonal=function(e,n,d){const a=sub(n,e),f=sub(d,n);return cross(a,f)},intersect=function(e,n,d){for(let a of e)for(let e of n)if(a===e)for(let e of d)if(a===e)return a;return null},calcCentroid=function(e){let n=[0,0,0];for(let d of e)n=add(n,d);return mult(1/e.length,n)},normal=function(e){let n=[0,0,0],[d,a]=Array.from(e.slice(-2));for(let f of e)n=add(n,orthogonal(d,a,f)),[d,a]=Array.from([a,f]);return unit(n)},convexarea=function(e){let n=0,[d,a]=Array.from(e.slice(0,2));for(let f of e.slice(2))n+=mag(cross(sub(a,d),sub(f,d))),a=f;return n},faceSignature=function(e){let n;const d=[];let[a,f]=Array.from(e.slice(0,2));for(let n of e.slice(2))d.push(mag(cross(sub(f,a),sub(n,a)))),f=n;d.sort((e,n)=>e-n);let l="";for(n of d)l+=sigfigs(n,2);for(n of d.reverse())l+=sigfigs(n,2);return l},project2dface=function(e){let d=clone(e);const a=e[0];d=_.map(d,e=>e-a);const f=normal(e),n=unit(calcCentroid(e)),l=cross(f,n);return d.map(e=>[dot(f,e),dot(l,e)])},copyVecArray=function(e){const n=Array(e.length);for(let d=0,a=e.length;d<a;d++)n[d]=e[d].slice(0);return n},mv3=(e,n)=>[e[0][0]*n[0]+e[0][1]*n[1]+e[0][2]*n[2],e[1][0]*n[0]+e[1][1]*n[1]+e[1][2]*n[2],e[2][0]*n[0]+e[2][1]*n[1]+e[2][2]*n[2]],mm3=(e,n)=>[[e[0][0]*n[0][0]+e[0][1]*n[1][0]+e[0][2]*n[2][0],e[0][0]*n[0][1]+e[0][1]*n[1][1]+e[0][2]*n[2][1],e[0][0]*n[0][2]+e[0][1]*n[1][2]+e[0][2]*n[2][2]],[e[1][0]*n[0][0]+e[1][1]*n[1][0]+e[1][2]*n[2][0],e[1][0]*n[0][1]+e[1][1]*n[1][1]+e[1][2]*n[2][1],e[1][0]*n[0][2]+e[1][1]*n[1][2]+e[1][2]*n[2][2]],[e[2][0]*n[0][0]+e[2][1]*n[1][0]+e[2][2]*n[2][0],e[2][0]*n[0][1]+e[2][1]*n[1][1]+e[2][2]*n[2][1],e[2][0]*n[0][2]+e[2][1]*n[1][2]+e[2][2]*n[2][2]]],eye3=[[1,0,0],[0,1,0],[0,0,1]],rotm=function(e,n,d){const a=[[cos(e),-1*sin(e),0],[sin(e),cos(e),0],[0,0,1]],f=[[cos(n),0,-1*sin(n)],[0,1,0],[sin(n),0,cos(n)]],l=[[1,0,0],[0,cos(d),-1*sin(d)],[0,sin(d),cos(d)]];return mm3(l,mm3(f,a))},vec_rotm=function(e,n,d,a){let f;e/=2;const l=sin(e),i=cos(e),u=l*l,t=mag([n,d,a]);if(0===t&&([n,d,a]=Array.from([0,0,1])),1!==t&&([n,d,a]=Array.from(unit([n,d,a]))),1===n&&0===d&&0===a)f=[[1,0,0],[0,1-2*u,2*l*i],[0,-2*l*i,1-2*u]];else if(0===n&&1===d&&0===a)f=[[1-2*u,0,-2*l*i],[0,1,0],[2*l*i,0,1-2*u]];else if(0===n&&0===d&&1===a)f=[[1-2*u,2*l*i,0],[-2*l*i,1-2*u,0],[0,0,1]];else{const e=n*n,t=d*d,c=a*a;f=[[1-2*(t+c)*u,2*(n*d*u+a*l*i),2*(n*a*u-d*l*i)],[2*(d*n*u-a*l*i),1-2*(c+e)*u,2*(d*a*u+n*l*i)],[2*(a*n*u+d*l*i),2*(a*d*u-n*l*i),1-2*(e+t)*u]]}return f},perspT=function(e,n,d,a,f){const l=(n*a-d)/(1-a),i=f*a/(1-a);return[i*e[0]/(e[2]+l),i*e[1]/(e[2]+l)]},invperspT=function(e,n,d,a,f,l,i,u){const t=(f*i-l)/(1-i),c=u*i/(1-i),s=e-d,g=n-a,o=c*c,h=t*t,p=s*s,r=g*g,m=(2*c*s*t+sqrt(4*o*p*h+4*p*(o+p+r)*(1-h)))/(2*(o+p+r)),y=c*g*t/(o+p+r)+g*sqrt(4*o*h+4*(o+p+r)*(1-h))/(2*(o+p+r)),x=sqrt(1-m*m-y*y);return[m,y,x]},getVec2VecRotM=function(e,n){const d=cross(e,n),a=acos(dot(e,n));return vec_rotm(-1*a,d[0],d[1],d[2])},faceToEdges=function(e){const n=[];let[d]=Array.from(e.slice(-1));for(let a of e)n.push([d,a]),d=a;return n},vertColors=function(e){const n=[];for(let d=0;d<e.face.length;d++){const a=e.face[d];for(let f of a)n[f]=e.face_class[d]}return n},rwb_palette=["#ff7777","#dddddd","#889999","#fff0e5","#aa3333","#ff0000","#ffffff","#aaaaaa"],hextofloats=function(e){let n;return"#"===e[0]&&(e=e.slice(1)),n=3===e.length?e.split("").map(e=>parseInt(e+e,16)/255):e.match(/.{2}/g).map(e=>parseInt(e,16)/255),n},PALETTE=rwb_palette,palette=function(e){return e<PALETTE.length?hextofloats(PALETTE[e]):hextofloats(PALETTE[PALETTE.length-1])},paintPolyhedron=function(e){let n;e.face_class=[];const d={},a=function(e,n){const d=round(100*e);if(d in n)return n[d];else{const e=_.toArray(n).length;return n[d]=e,e}};for(var l of e.face){var f,i;"area"===COLOR_METHOD?(i=(()=>{const d=[];for(n of l)d.push(e.xyz[n]);return d})(),f=a(convexarea(i),d)):"signature"===COLOR_METHOD?(i=(()=>{const d=[];for(n of l)d.push(e.xyz[n]);return d})(),f=a(faceSignature(i),d)):f=l.length-3,e.face_class.push(f)}return console.log(_.toArray(d).length+" face classes"),e},sortfaces=function(e){let n;const d=e.centers(),a=e.normals(),f=[0,0,(persp_z_max*persp_ratio-persp_z_min)/(1-persp_ratio)],l=_.zip(d,a,__range__(0,e.face.length,!1)).sort((e,n)=>e[0][2]-n[0][2]).map(e=>e[2]);return e.face=(()=>{const d=[];for(n of l)d.push(e.face[n]);return d})(),e.face_class=(()=>{const d=[];for(n of l)d.push(e.face_class[n]);return d})()};class polyhedron{constructor(e,n,d){this.face=n||[],this.xyz=e||[],this.name=d||"null polyhedron"}data(){const e=this.face.length+this.xyz.length-2;return`${this.face.length} faces, ${e} edges, ${this.xyz.length} vertices`}moreData(){return`min. edge length ${this.minEdgeLength().toPrecision(2)}; min. face radius ${this.minFaceRadius().toPrecision(2)}`}edges(){let n;const d={},f=[],l=_.map(this.face,faceToEdges);for(let e of l)for(n of e){var i,u;n[0]<n[1]?[i,u]=Array.from(n):[u,i]=Array.from(n),d[i+"~"+u]=n}for(let e in d)n=d[e],f.push(n);return f}minEdgeLength(){let n=Number.MAX_VALUE;for(let d of this.edges()){const e=mag2(sub(this.xyz[d[0]],this.xyz[d[1]]));e<n&&(n=e)}return sqrt(n)}minFaceRadius(){let n=Number.MAX_VALUE;const d=this.face.length,a=this.centers();for(let l=0,e=d,f=0<=e;f?l<e:l>e;f?l++:l--){const d=a[l];for(let a of faceToEdges(this.face[l])){const e=linePointDist2(this.xyz[a[0]],this.xyz[a[1]],d);e<n&&(n=e)}}return sqrt(n)}centers(){const e=[];for(let n of this.face){let d=[0,0,0];for(let e of n)d=add(d,this.xyz[e]);e.push(mult(1/n.length,d))}return e}normals(){const e=[];for(let n of this.face)e.push(normal(n.map(e=>this.xyz[e])));return e}toOBJ(){let e,n,d="#Produced by polyH\xE9dronisme http://levskaya.github.com/polyhedronisme\n";d+=`group ${this.name}\n`,d+="#vertices\n";for(n of this.xyz)d+=`v ${n[0]} ${n[1]} ${n[2]}\n`;d+="#normal vector defs \n";for(e of this.face){const a=normal((()=>{const d=[];for(n of e)d.push(this.xyz[n]);return d})());d+=`vn ${a[0]} ${a[1]} ${a[2]}\n`}d+="#face defs \n";for(let a=0;a<this.face.length;a++){e=this.face[a],d+="f ";for(n of e)d+=`${n+1}//${a+1} `;d+="\n"}return d}toX3D(){let e;const n=.01;let d=`\
<?xml version="1.0" encoding ="UTF-8"?>
<X3D profile="Interchange" version="3.0">
<head>
<component name="Rendering" level="3"/>
<meta name="generator" content="Polyhedronisme"/>
<meta name="version" content="0.1.0"/>
</head>
<Scene>
<Shape>
<IndexedFaceSet normalPerVertex="false" coordIndex="\
`;for(let n of this.face){for(e of n)d+=`${e} `;d+="-1\n"}d+="\">\n",d+="<Color color=\"";for(let e of vertColors(this)){const n=palette(e);d+=`${n[0]} ${n[1]} ${n[2]} `}d+="\"/>",d+="<Coordinate point=\"";for(e of this.xyz)d+=`${e[0]*n} ${e[1]*n} ${e[2]*n} `;return d+="\"/>\n",d+=`\
</IndexedFaceSet>
</Shape>
</Scene>
</X3D>`,d}toVRML(){let e;const n=.01;let d=`\
#VRML V2.0 utf8
#Generated by Polyhedronisme
NavigationInfo {
	type [ "EXAMINE", "ANY" ]
}
Transform {
  scale 1 1 1
  translation 0 0 0
  children
  [
    Shape
    {
      geometry IndexedFaceSet
      {
        creaseAngle .5
        solid FALSE
        coord Coordinate
        {
          point
          [\
`;for(e of this.xyz)d+=`${e[0]*n} ${e[1]*n} ${e[2]*n},`;d=d.slice(0,-1),d+=`\
    ]
}
color Color
{
  color
  [\
`;for(let e of this.face_class){const n=palette(e);d+=`${n[0]} ${n[1]} ${n[2]} ,`}d=d.slice(0,-1),d+=`\
  ]
}
colorPerVertex FALSE
coordIndex
[\
`;for(let n of this.face){for(e of n)d+=`${e}, `;d+="-1,"}return d=d.slice(0,-1),d+=`\
          ]
      }
      appearance Appearance
      {
        material Material
        {
	       ambientIntensity 0.2
	       diffuseColor 0.9 0.9 0.9
	       specularColor .1 .1 .1
	       shininess .5
        }
      }
    }
  ]
}\
`,d}}const tetrahedron=function(){const e=new polyhedron;return e.name="T",e.face=[[0,1,2],[0,2,3],[0,3,1],[1,3,2]],e.xyz=[[1,1,1],[1,-1,-1],[-1,1,-1],[-1,-1,1]],e},octahedron=function(){const e=new polyhedron;return e.name="O",e.face=[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]],e.xyz=[[0,0,1.414],[1.414,0,0],[0,1.414,0],[-1.414,0,0],[0,-1.414,0],[0,0,-1.414]],e},cube=function(){const e=new polyhedron;return e.name="C",e.face=[[3,0,1,2],[3,4,5,0],[0,5,6,1],[1,6,7,2],[2,7,4,3],[5,4,7,6]],e.xyz=[[.707,.707,.707],[-.707,.707,.707],[-.707,-.707,.707],[.707,-.707,.707],[.707,-.707,-.707],[.707,.707,-.707],[-.707,.707,-.707],[-.707,-.707,-.707]],e},icosahedron=function(){const e=new polyhedron;return e.name="I",e.face=[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]],e.xyz=[[0,0,1.176],[1.051,0,.526],[.324,1,.525],[-.851,.618,.526],[-.851,-.618,.526],[.325,-1,.526],[.851,.618,-.526],[.851,-.618,-.526],[-.325,1,-.526],[-1.051,0,-.526],[-.325,-1,-.526],[0,0,-1.176]],e},dodecahedron=function(){const e=new polyhedron;return e.name="D",e.face=[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]],e.xyz=[[0,0,1.07047],[.713644,0,.797878],[-.356822,.618,.797878],[-.356822,-.618,.797878],[.797878,.618034,.356822],[.797878,-.618,.356822],[-.934172,.381966,.356822],[.136294,1,.356822],[.136294,-1,.356822],[-.934172,-.381966,.356822],[.934172,.381966,-.356822],[.934172,-.381966,-.356822],[-.797878,.618,-.356822],[-.136294,1,-.356822],[-.136294,-1,-.356822],[-.797878,-.618034,-.356822],[.356822,.618,-.797878],[.356822,-.618,-.797878],[-.713644,0,-.797878],[0,0,-1.07047]],e},prism=function(e){var n=Math.sin;let d,a,f,l,u,t,c;const s=2*PI/e,g=n(s/2);let o=new polyhedron;for(o.name=`P${e}`,d=0,f=e,a=0<=f;a?d<f:d>f;a?d++:d--)o.xyz.push([-cos(d*s),-sin(d*s),-g]);for(d=0,u=e,l=0<=u;l?d<u:d>u;l?d++:d--)o.xyz.push([-cos(d*s),-sin(d*s),g]);for(o.face.push(__range__(e-1,0,!0)),o.face.push(__range__(e,2*e,!1)),(d=0,c=e,t=0<=c);t?d<c:d>c;t?d++:d--)o.face.push([d,(d+1)%e,(d+1)%e+e,d+e]);return o=adjustXYZ(o,1),o},antiprism=function(e){let n,d,a,l,u,t,c;const s=2*PI/e;let g=sqrt(1-4/(4+2*cos(s/2)-2*cos(s))),o=sqrt(1-g*g);const p=sqrt(g*g+pow(o*cos(s/2),2));o=-o/p,g=-g/p;let f=new polyhedron;for(f.name=`A${e}`,n=0,a=e,d=0<=a;d?n<a:n>a;d?n++:n--)f.xyz.push([o*cos(n*s),o*sin(n*s),g]);for(n=0,u=e,l=0<=u;l?n<u:n>u;l?n++:n--)f.xyz.push([o*cos((n+.5)*s),o*sin((n+.5)*s),-g]);for(f.face.push(__range__(e-1,0,!0)),f.face.push(__range__(e,2*e-1,!0)),(n=0,c=e-1,t=0<=c);t?n<=c:n>=c;t?n++:n--)f.face.push([n,(n+1)%e,n+e]),f.face.push([n,n+e,(e+n-1)%e+e]);return f=adjustXYZ(f,1),f},pyramid=function(e){let n,d,a,f,l;const u=2*PI/e;let t=new polyhedron;for(t.name=`Y${e}`,n=0,a=e,d=0<=a;d?n<a:n>a;d?n++:n--)t.xyz.push([-cos(n*u),-sin(n*u),-.2]);for(t.xyz.push([0,0,1]),t.face.push(__range__(e-1,0,!0)),(n=0,l=e,f=0<=l);f?n<l:n>l;f?n++:n--)t.face.push([n,(n+1)%e,e]);return t=canonicalXYZ(t,3),t};function __range__(e,n,d){let a=[],f=e<n,l=d?f?n+1:n-1:n;for(let u=e;f?u<l:u>l;f?u++:u--)a.push(u);return a}class polyflag{constructor(){this.flags={},this.verts={},this.xyzs={}}newV(e,n){if(void 0===this.verts[e])return this.verts[e]=0,this.xyzs[e]=n}newFlag(e,n,d){return void 0===this.flags[e]&&(this.flags[e]={}),this.flags[e][n]=d}topoly(){let e,n;const d=new polyhedron;let a=0;for(e in this.verts)n=this.verts[e],d.xyz[a]=this.xyzs[e],this.verts[e]=a,a++;for(e in a=0,this.flags){var l;const i=this.flags[e];for(let e in d.face[a]=[],i){n=i[e],l=n;break}n=l,d.face[a].push(this.verts[n]),n=this.flags[e][n];for(let f=0;n!==l;)if(d.face[a].push(this.verts[n]),n=this.flags[e][n],f++,1e3<f){console.log("Bad flag spec, have a neverending face:",e,this.flags[e]);break}a++}return d.name="unknown polyhedron",d}}const kisN=function(e,d,a){let l;d||(d=0),a||(a=.1),console.log(`Taking kis of ${0===d?"":d}-sided faces of ${e.name}...`);const u=new polyflag;for(l=0;l<e.xyz.length;l++){const n=e.xyz[l];u.newV(`v${l}`,n)}const t=e.normals(),c=e.centers();let s=!1;for(l=0;l<e.face.length;l++){const n=e.face[l];let f=`v${n[n.length-1]}`;for(let e of n){const i=`v${e}`;if(n.length===d||0===d){s=!0;const e=`apex${l}`,n=`${l}${f}`;u.newV(e,add(c[l],mult(a,t[l]))),u.newFlag(n,f,i),u.newFlag(n,i,e),u.newFlag(n,e,f)}else u.newFlag(`${l}`,f,i);f=i}}s||console.log(`No ${d}-fold components were found.`);const g=u.topoly();return g.name=`k${0===d?"":d}${e.name}`,g},ambo=function(e){console.log(`Taking ambo of ${e.name}...`);const n=function(e,n){return e<n?e+"_"+n:n+"_"+e},d=new polyflag;for(let a=0;a<e.face.length;a++){const l=e.face[a];let[f,i]=Array.from(l.slice(-2));for(let u of l)f<i&&d.newV(n(f,i),midpoint(e.xyz[f],e.xyz[i])),d.newFlag(`orig${a}`,n(f,i),n(i,u)),d.newFlag(`dual${i}`,n(i,u),n(f,i)),[f,i]=Array.from([i,u])}const a=d.topoly();return a.name=`a${e.name}`,a},gyro=function(e){let n,d,a;console.log(`Taking gyro of ${e.name}...`);const l=new polyflag;for(d=0;d<e.xyz.length;d++)a=e.xyz[d],l.newV(`v${d}`,unit(a));const u=e.centers();for(d=0;d<e.face.length;d++)n=e.face[d],l.newV(`center${d}`,unit(u[d]));for(d=0;d<e.face.length;d++){n=e.face[d];let[f,i]=Array.from(n.slice(-2));for(let u=0;u<n.length;u++){a=n[u];const t=a;l.newV(f+"~"+i,oneThird(e.xyz[f],e.xyz[i]));const c=d+"f"+f;l.newFlag(c,`center${d}`,f+"~"+i),l.newFlag(c,f+"~"+i,i+"~"+f),l.newFlag(c,i+"~"+f,`v${i}`),l.newFlag(c,`v${i}`,i+"~"+t),l.newFlag(c,i+"~"+t,`center${d}`),[f,i]=Array.from([i,t])}}const t=l.topoly();return t.name=`g${e.name}`,t},propellor=function(e){let n,d;console.log(`Taking propellor of ${e.name}...`);const a=new polyflag;for(n=0;n<e.xyz.length;n++)d=e.xyz[n],a.newV(`v${n}`,unit(d));for(n=0;n<e.face.length;n++){const l=e.face[n];let[f,i]=Array.from(l.slice(-2));for(d of l){const l=`${d}`;a.newV(f+"~"+i,oneThird(e.xyz[f],e.xyz[i]));const u=`${n}f${i}`;a.newFlag(`v${n}`,f+"~"+i,i+"~"+l),a.newFlag(u,f+"~"+i,i+"~"+f),a.newFlag(u,i+"~"+f,`v${i}`),a.newFlag(u,`v${i}`,i+"~"+l),a.newFlag(u,i+"~"+l,f+"~"+i),[f,i]=Array.from([i,l])}}const f=a.topoly();return f.name=`p${e.name}`,f},reflect=function(e){let n,d,a,f,l;for(console.log(`Taking reflection of ${e.name}...`),n=0,a=e.xyz.length-1,d=0<=a;d?n<=a:n>=a;d?n++:n--)e.xyz[n]=mult(-1,e.xyz[n]);for(n=0,l=e.face.length-1,f=0<=l;f?n<=l:n>=l;f?n++:n--)e.face[n]=e.face[n].reverse();return e.name=`r${e.name}`,e},dual=function(e){let n,d,a,l,u,t,c,s;console.log(`Taking dual of ${e.name}...`);const g=new polyflag,o=[];for(d=0,t=e.xyz.length-1,u=0<=t;u?d<=t:d>=t;u?d++:d--)o[d]={};for(d=0;d<e.face.length;d++){n=e.face[d],a=n[n.length-1];for(l of n)o[a][`v${l}`]=`${d}`,a=l}const h=e.centers();for(d=0,s=e.face.length-1,c=0<=s;c?d<=s:d>=s;c?d++:d--)g.newV(`${d}`,h[d]);for(d=0;d<e.face.length;d++){n=e.face[d],a=n[n.length-1];for(l of n)g.newFlag(a,o[l][`v${a}`],`${d}`),a=l}const p=g.topoly(),r=[];for(n of p.face){const d=intersect(e.face[n[0]],e.face[n[1]],e.face[n[2]]);r[d]=n}return p.face=r,p.name="d"===e.name[0]?e.name.slice(1):`d${e.name}`,p},chamfer=function(e,n){console.log(`Taking chamfer of ${e.name}...`),n||(n=.5);const d=new polyflag,a=e.normals();for(let l=0;l<e.face.length;l++){const i=e.face[l];let f=i[i.length-1],u=l+"_"+f;for(let t of i){d.newV(t,mult(1+n,e.xyz[t]));const i=l+"_"+t;d.newV(i,add(e.xyz[t],mult(1.5*n,a[l]))),d.newFlag(`orig${l}`,u,i);const c=f<t?`hex${f}_${t}`:`hex${t}_${f}`;d.newFlag(c,t,i),d.newFlag(c,i,u),d.newFlag(c,u,f),f=t,u=i}}const f=d.topoly();return f.name=`c${e.name}`,f},whirl=function(e,d){let a,l;console.log(`Taking whirl of ${e.name}...`),d||(d=0);const u=new polyflag;for(a=0;a<e.xyz.length;a++)l=e.xyz[a],u.newV(`v${a}`,unit(l));const t=e.centers();for(a=0;a<e.face.length;a++){const n=e.face[a];let[d,f]=Array.from(n.slice(-2));for(let i=0;i<n.length;i++){l=n[i];const c=l,s=oneThird(e.xyz[d],e.xyz[f]);u.newV(d+"~"+f,s);const g=`center${a}~${d}`,o=`center${a}~${f}`;u.newV(g,unit(oneThird(t[a],s)));const h=a+"f"+d;u.newFlag(h,g,d+"~"+f),u.newFlag(h,d+"~"+f,f+"~"+d),u.newFlag(h,f+"~"+d,`v${f}`),u.newFlag(h,`v${f}`,f+"~"+c),u.newFlag(h,f+"~"+c,o),u.newFlag(h,o,g),u.newFlag(`c${a}`,g,o),[d,f]=Array.from([f,c])}}const c=u.topoly();return c.name=`w${e.name}`,c},insetN=function(e,d,a,l){let u,t,c;d||(d=0),a||(a=.5),l||(l=-.2),console.log(`Taking inset of ${0===d?"":d}-sided faces of ${e.name}...`);const s=new polyflag;for(t=0;t<e.xyz.length;t++){const n=e.xyz[t];s.newV(`v${t}`,n)}const g=e.normals(),o=e.centers();for(t=0;t<e.face.length;t++)if(u=e.face[t],u.length===d||0===d)for(c of u)s.newV(`f${t}v${c}`,add(tween(e.xyz[c],o[t],a),mult(l,g[t])));let h=!1;for(t=0;t<e.face.length;t++){u=e.face[t];let n=`v${u[u.length-1]}`;for(c of u){const e=`v${c}`;if(u.length===d||0===d){h=!0;const d=t+n;s.newFlag(d,n,e),s.newFlag(d,e,`f${t}${e}`),s.newFlag(d,`f${t}${e}`,`f${t}${n}`),s.newFlag(d,`f${t}${n}`,n),s.newFlag(`ex${t}`,`f${t}${n}`,`f${t}${e}`)}else s.newFlag(t,n,e);n=e}}h||console.log(`No ${d}-fold components were found.`);const p=s.topoly();return p.name=`n${0===d?"":d}${e.name}`,p},extrudeN=function(e,d){let a,l,u;d||(d=0),console.log(`Taking extrusion of ${0===d?"":d}-sided faces of ${e.name}...`);const t=new polyflag;for(l=0;l<e.xyz.length;l++){const n=e.xyz[l];t.newV(`v${l}`,n)}const c=e.normals(),s=e.centers();for(l=0;l<e.face.length;l++)if(a=e.face[l],a.length===d||0===d)for(u of a)t.newV(`f${l}v${u}`,add(e.xyz[u],mult(.3,c[l])));let g=!1;for(l=0;l<e.face.length;l++){a=e.face[l];let n=`v${a[a.length-1]}`;for(u of a){const e=`v${u}`;a.length===d||0===d?(g=!0,t.newFlag(l+n,n,e),t.newFlag(l+n,e,`f${l}${e}`),t.newFlag(l+n,`f${l}${e}`,`f${l}${n}`),t.newFlag(l+n,`f${l}${n}`,n),t.newFlag(`ex${l}`,`f${l}${n}`,`f${l}${e}`)):t.newFlag(l,n,e),n=e}}g||console.log(`No ${d}-fold components were found.`);const o=t.topoly();return o.name=`x${0===d?"":d}${e.name}`,o},hollow=function(e,d,a,l){let u,t,c;d||(d=0),a||(a=.5),l||(l=.2),console.log(`Skeletonizing ${0===d?"":d}-sided faces of ${e.name}...`);const s=dual(e).normals(),g=e.normals(),o=e.centers(),h=new polyflag;for(t=0;t<e.xyz.length;t++){const n=e.xyz[t];h.newV(`v${t}`,n),h.newV(`downv${t}`,add(n,mult(-1*l,s[t])))}for(t=0;t<e.face.length;t++){u=e.face[t];for(c of u)h.newV(`fin${t}v${c}`,tween(e.xyz[c],o[t],a)),h.newV(`findown${t}v${c}`,add(tween(e.xyz[c],o[t],a),mult(-1*l,g[t])))}for(t=0;t<e.face.length;t++){u=e.face[t];let n=`v${u[u.length-1]}`;for(c of u){const e=`v${c}`;let d=t+n;h.newFlag(d,n,e),h.newFlag(d,e,`fin${t}${e}`),h.newFlag(d,`fin${t}${e}`,`fin${t}${n}`),h.newFlag(d,`fin${t}${n}`,n),d=`sides${t}${n}`,h.newFlag(d,`fin${t}${n}`,`fin${t}${e}`),h.newFlag(d,`fin${t}${e}`,`findown${t}${e}`),h.newFlag(d,`findown${t}${e}`,`findown${t}${n}`),h.newFlag(d,`findown${t}${n}`,`fin${t}${n}`),d=`bottom${t}${n}`,h.newFlag(d,`down${e}`,`down${n}`),h.newFlag(d,`down${n}`,`findown${t}${n}`),h.newFlag(d,`findown${t}${n}`,`findown${t}${e}`),h.newFlag(d,`findown${t}${e}`,`down${e}`),n=e}}const p=h.topoly();return p.name=`h${e.name}`,p},stellaN=function(e){let n;console.log(`Taking stella of ${e.name}...`);const d=e.centers(),a=new polyflag;for(n=0;n<e.xyz.length;n++){const d=e.xyz[n];a.newV(`v${n}`,d)}for(n=0;n<e.face.length;n++){const l=e.face[n];let f=`v${l[l.length-2]}`,i=`v${l[l.length-1]}`,u=e.xyz[l[l.length-2]],t=e.xyz[l[l.length-1]];for(let c of l){const l=`v${c}`,s=e.xyz[c],g=f+"~"+i,o=i+"~"+f,h=i+"~"+l;a.newV(g,midpoint(midpoint(u,t),d[n])),a.newFlag(`in${n}`,g,h),a.newFlag(`f${n}${i}`,h,g),a.newFlag(`f${n}${i}`,g,i),a.newFlag(`f${n}${i}`,i,h),a.newFlag(`f${g}`,f,o),a.newFlag(`f${g}`,o,g),a.newFlag(`f${g}`,g,f),[f,i]=Array.from([i,l]),[u,t]=Array.from([t,s])}}const f=a.topoly();return f.name=`l${e.name}`,f},tangentify=function(e,n){const d=copyVecArray(e);for(let a of n){const e=tangentPoint(d[a[0]],d[a[1]]),n=mult(1*.1/2*(1-sqrt(dot(e,e))),e);d[a[0]]=add(d[a[0]],n),d[a[1]]=add(d[a[1]],n)}return d},recenter=function(e,n){const d=(()=>{const d=[];for(let[f,a]of n)d.push(tangentPoint(e[f],e[a]));return d})();let a=[0,0,0];for(let f of d)a=add(a,f);return a=mult(1/n.length,a),_.map(e,e=>sub(e,a))},rescale=function(e){const n=_.max(_.map(e,e=>mag(e))),d=1/n;return _.map(e,e=>[d*e[0],d*e[1],d*e[2]])},planarize=function(e,n){let d;const a=copyVecArray(e);for(var l of n){const f=(()=>{const n=[];for(d of l)n.push(e[d]);return n})();let i=normal(f);const n=calcCentroid(f);0>dot(i,n)&&(i=mult(-1,i));for(d of l)a[d]=add(a[d],mult(dot(mult(.1,i),sub(n,e[d])),i))}return a},canonicalize=function(e,n){n||(n=1),console.log(`Canonicalizing ${e.name}...`);const d=e.face,a=e.edges();let f=e.xyz,l=1;for(let u=0,i=n,t=0<=i;t?u<=i:u>=i;t?u++:u--){const e=copyVecArray(f);if(f=tangentify(f,a),f=recenter(f,a),f=planarize(f,d),l=_.max(_.map(_.zip(f,e),function(...e){const[n,d]=e[0];return mag(sub(n,d))})),1e-8>l)break}console.log(`[canonicalization done, last |deltaV|=${l}]`);const i=new polyhedron(f,e.face,e.name);return console.log("canonicalize",i),i},reciprocalC=function(e){const n=e.centers();for(let d of n)d=mult(1/dot(d,d),d);return n},reciprocalN=function(e){const n=[];for(let d of e.face){let a=[0,0,0],f=[0,0,0],l=0,[i,u]=d.slice(-2);for(let n of d)a=add(a,e.xyz[n]),f=add(f,orthogonal(e.xyz[i],e.xyz[u],e.xyz[n])),l+=edgeDist(e.xyz[i],e.xyz[u]),[i,u]=[u,n];a=mult(1/d.length,a),f=unit(f),l/=d.length;const t=reciprocal(mult(dot(a,f),f));n.push(mult((1+l)/2,t))}return n},canonicalXYZ=function(e,n){n||(n=1);const d=dual(e);console.log(`Pseudo-canonicalizing ${e.name}...`);for(let a=0,f=n;a<f;a++)d.xyz=reciprocalN(e),e.xyz=reciprocalN(d);return new polyhedron(e.xyz,e.face,e.name)},adjustXYZ=function(e,n){n||(n=1);const d=dual(e);console.log(`Planarizing ${e.name}...`);for(let a=0,f=n;a<f;a++)d.xyz=reciprocalC(e),e.xyz=reciprocalC(d);return new polyhedron(e.xyz,e.face,e.name)},getDiagonals=function(e){let d,a;const f=[],l=[];let i=e.length;const u=(e,n)=>(e||n)&&!(e&&n),t=(e,n,d)=>(n[0]-e[0])*(d[1]-e[1])-(d[0]-e[0])*(n[1]-e[1]),c=(e,n,d)=>0<t(e,n,d),s=(e,n,d)=>0<=t(e,n,d),g=(e,n,d)=>0===t(e,n,d),o=function(e,n,d){return!g(e,n,d)&&(e[0]===n[0]?e[1]<=d[1]&&d[1]<=n[1]||e[1]>=d[1]&&d[1]>=n[1]:e[0]<=d[0]&&d[0]<=n[0]||e[0]>=d[0]&&d[0]>=n[0])},h=function(e,n,d,a){return!(g(e,n,d)||g(e,n,a)||g(d,a,e)||g(d,a,n))&&u(c(e,n,d),c(e,n,a))&&u(c(d,a,e),c(d,a,n))},p=function(n,d){const a=(n+1+i)%i,f=(n-1+i)%i;return s(e[n],e[a],e[f])?c(e[n],e[d],e[f])&&c(e[d],e[n],e[a]):!(s(e[n],e[d],e[a])&&s(e[d],e[n],e[f]))},r=function(n,d){for(let a=0;;){const f=(a+1+i)%i;if(a!==n&&f!==n&&a!==d&&f!==d&&h(e[n],e[d],e[a],e[f]))return!1;if(a=(a+1+i)%i,0===a)break}return!0},m=(e,n)=>p(e,n)&&p(n,e)&&r(e,n);let y=0;for(;a=(y+1+i)%i,d=(y-1+i)%i,l[y]=m(d,a),y=(y+1+i)%i,0!=y;);let x=__range__(0,i-1,!0),w=i,v=999,F=0;for(;0<v&&3<w;){v-=1,a=F;for(let n=999;;){n-=1;let u=!1;if(l[a]){let n=(a+1+i)%i,t=(n+1+i)%i;y=(a-1+i)%i,d=(y-1+i)%i,f.push([x[y],x[n]]),l[y]=m(d,n),l[n]=m(y,t),e=e.slice(0,+a+1||void 0).concat(e.slice(n)),x=x.slice(0,+a+1||void 0).concat(x.slice(n)),d>a&&(d-=1),y>a&&(y-=1),n>a&&(n-=1),t>a&&(t-=1),i--,F=n,w--,u=!0}if(a=(a+1+i)%i,0>=n||!!u||a===F)break}}return f},triEq=function(e,n){return!((e[0]!==n[0]||e[1]!==n[1]||e[2]!==n[2])&&(e[0]!==n[1]||e[1]!==n[2]||e[2]!==n[0])&&(e[0]!==n[2]||e[1]!==n[0]||e[2]!==n[1]))},diagsToTris=function(e,n){let a;const f=[],l=[];for(let[d,a]of __range__(0,e.length-1,!0).map(n=>[n,(n+1)%e.length]))f[d]=[a],l[a]=[d];for(a of n)f[a[0]].push(a[1]),f[a[1]].push(a[0]),l[a[0]].push(a[1]),l[a[1]].push(a[0]);const i=[];for(a of n){var u,t;for(u of f[a[1]])for(t of l[a[0]])u===t&&i.push([a[0],a[1],u]);for(u of f[a[0]])for(t of l[a[1]])u===t&&i.push([a[1],a[0],u])}const c=[i.pop()];for(let d of i){let e=!1;for(let n of c)if(triEq(d,n)){e=!0;break}e||c.push(d)}return c},triangulate=function(e,n){n=n||!1,console.log(`Triangulating faces of ${e.name}...`);const d=new polyhedron;d.xyz=clone(e.xyz),d.face_class=[];for(let a=0;a<e.face.length;a++){const l=e.face[a];if(3<l.length){const f=project2dface(l.map(n=>e.xyz[n])),i=getDiagonals(f),u=diagsToTris(l,i);for(let f=0;f<u.length;f++){const i=u[f];d.face.push([l[i[0]],l[i[1]],l[i[2]]]),n&&d.face_class.push(e.face_class[a])}}else d.face.push([l[0],l[1],l[2]]),n&&d.face_class.push(e.face_class[a])}return d.name=e.name,d};function __range__(e,n,d){let a=[],f=e<n,l=d?f?n+1:n-1:n;for(let u=e;f?u<l:u>l;f?u++:u--)a.push(u);return a}const topolog=function(e){let n="";for(let d of e.face){for(let e of d)n+=`${e}->`;n+="\n"}return console.log(n)},testrig=function(){const e=["T","O","C","I","D","P3","P4","A4","A5","Y3","Y4"],n=["k","a","g","p","d","n","x","*"];console.log("===== Test Basic Ops =====");for(let d of n){console.log(`Operator ${d}`);for(let n of e)console.log(d+n+":",generatePoly(d+n))}return console.log("===== Done Testing Basic Ops =====")},PEG_parser_spec=`\
/* series of opspecs */
start  = opspec+

/* opspec one of:
 A  - single letter
 A3 - single letter and float
 B(5,4.3,3) - function call format w. float args
*/
opspec =
   let:opcode args:opargs {return {"op":let,"args":args};}
/ let:opcode float:float     {return {"op":let,"args":[float]};}
/ let:opcode                     {return {"op":let,"args":[]};}

/*
parentheses surrounding comma-delimited list of floats i.e.
( 1 , 3.2, 4 ) or (1) or (2,3)
*/
opargs = "("
           num:( float:float ","? {return float} )+
         ")" {return num;}

/* just a letter */
opcode = op:[a-zA-Z] {return op;}

/* standard numerical types */
int   = digits:[0-9-]+   { return parseInt(digits.join(""), 10);  }
float = digits:[0-9.-]+  { return parseFloat(digits.join(""), 10); }\
`,op_parser=PEG.buildParser(PEG_parser_spec),dispatch=function(e,n){return e.apply(this,n||[])},basemap={T:tetrahedron,O:octahedron,C:cube,I:icosahedron,D:dodecahedron,P:prism,A:antiprism,Y:pyramid},opmap={d:dual,k:kisN,a:ambo,g:gyro,p:propellor,r:reflect,h:hollow,c:chamfer,w:whirl,n:insetN,x:extrudeN,l:stellaN,z:triangulate,K:canonicalXYZ,C:canonicalize,A:adjustXYZ},specreplacements=[[/e/g,"aa"],[/b/g,"ta"],[/o/g,"jj"],[/m/g,"kj"],[/t(\d*)/g,"dk$1d"],[/j/g,"dad"],[/s/g,"dgd"],[/dd/g,""],[/ad/g,"a"],[/gd/g,"g"],[/aO/g,"aC"],[/aI/g,"aD"],[/gO/g,"gC"],[/gI/g,"gD"]],getOps=function(e){let n=e;for(let[d,a]of specreplacements)n=n.replace(d,a);return console.log(`${e} executed as ${n}`),n},newgeneratePoly=function(e){const n=getOps(e),d=op_parser.parse(n).reverse();let a=d.shift();const f=basemap[a.op],l=a.args;let i=dispatch(f,l);for(a of d){const e=opmap[a.op],n=[i].concat(a.args);i=dispatch(e,n)}return i.xyz=recenter(i.xyz,i.edges()),i.xyz=rescale(i.xyz),i=paintPolyhedron(i),i};let ctx={};const CANVAS_WIDTH=500,CANVAS_HEIGHT=400;let globPolys={},globRotM=clone(eye3),globlastRotM=clone(eye3),perspective_scale=800;const persp_z_max=5,persp_z_min=0,persp_ratio=.8,_2d_x_offset=250,_2d_y_offset=CANVAS_HEIGHT/2,globtime=new Date,BG_CLEAR=!0,BG_COLOR="rgba(255,255,255,1.0)",COLOR_METHOD="signature";let PaintMode="fillstroke";const ctx_linewidth=.5;let MOUSEDOWN=!1,LastMouseX=0,LastMouseY=0,LastSphVec=[1,0,0];const DEFAULT_RECIPES=["C2dakD","oC20kkkT","kn4C40A0dA4","opD","lT","lK5oC","knD","dn6x4K5bT","oox4P7","n18n18n9n9n9soxY9"],saveText=function(e,n){const d=new Blob([e],{type:`text/plain;charset=${document.characterSet}`});return saveAs(d,n)},parseurl=function(){let n;const f={},l=/\+/g,a=/([^&=]+)=?([^&]*)/g,i=e=>decodeURIComponent(e.replace(l," ")),d=window.location.search.substring(1);for(;n=a.exec(d);)f[i(n[1])]=i(n[2]);return f},setlink=function(){const e=$("#spec").val().split(/\s+/g).slice(0,2);let n=location.protocol+"//"+location.host+location.pathname;return n+=`?recipe=${encodeURIComponent(e[0])}`,PALETTE!==rwb_palette&&(n+=`&palette=${encodeURIComponent(PALETTE.reduce((e,n)=>e+" "+n))}`),$("#link").attr("href",n)},init=function(){const e=$("#poly");e.width(CANVAS_WIDTH),e.height(CANVAS_HEIGHT),ctx=e[0].getContext("2d"),ctx.lineWidth=ctx_linewidth,BG_CLEAR?ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT):(ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT),ctx.fillStyle=BG_COLOR,ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT));const n=$("#expandcollapse");return n.click(function(){return /minus/.test(n.attr("src"))?($("#morestats").hide(),n.attr("src","media/plus.png")):($("#morestats").show(),n.attr("src","media/minus.png"))})},clear=function(){return BG_CLEAR?ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT):(ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT),ctx.fillStyle=BG_COLOR,ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT))},drawpoly=function(e,n){let d;n||(n=[3,3,3]);const a=_.map(e.xyz,e=>e);e.xyz=_.map(e.xyz,e=>mv3(globRotM,e)),sortfaces(e);for(let a=0;a<e.face.length;a++){var f=e.face[a];ctx.beginPath();const l=f[f.length-1];let[i,u]=perspT(add(n,e.xyz[l]),persp_z_max,persp_z_min,persp_ratio,perspective_scale);ctx.moveTo(i+_2d_x_offset,u+_2d_y_offset);for(d of f)[i,u]=perspT(add(n,e.xyz[d]),persp_z_max,persp_z_min,persp_ratio,perspective_scale),ctx.lineTo(i+_2d_x_offset,u+_2d_y_offset);let t=palette(e.face_class[a]);const c=(()=>{const n=[];for(d of f)n.push(e.xyz[d]);return n})(),s=dot(normal(c),unit([1,-1,0]));t=mult(.7*(s/2+.5)+.3,t),("fill"==PaintMode||"fillstroke"==PaintMode)&&(ctx.fillStyle=`rgba(${round(255*t[0])}, ${round(255*t[1])}, ${round(255*t[2])}, ${1})`,ctx.fill(),ctx.strokeStyle=`rgba(${round(255*t[0])}, ${round(255*t[1])}, ${round(255*t[2])}, ${1})`,ctx.stroke()),"fillstroke"==PaintMode&&(ctx.fillStyle=`rgba(${round(255*t[0])}, ${round(255*t[1])}, ${round(255*t[2])}, ${1})`,ctx.fill(),ctx.strokeStyle="rgba(0,0,0, .3)",ctx.stroke()),"stroke"==PaintMode&&(ctx.strokeStyle="rgba(0,0,0, .8)",ctx.stroke())}return e.xyz=a},drawShape=function(){return clear(),globPolys.map((e,n)=>drawpoly(e,[0+3*n,0,3]))},updateStats=()=>(()=>{const e=[];for(let n=0;n<globPolys.length;n++){const d=globPolys[n];$("#basicstats").text(d.data()),e.push($("#morestats").text(d.moreData()))}return e})();var animateShape=function(){clear();.1*(2*Math.PI/180*globtime.getSeconds());for(let e=0;e<globPolys.length;e++){const n=globPolys[e];drawpoly(n,[0+3*e,0,3])}return setTimeout(animateShape,100)};$(function(){init();const e=parseurl();return"recipe"in e?(specs=[e.recipe],$("#spec").val(specs)):(specs=[randomchoice(DEFAULT_RECIPES)],$("#spec").val(specs),setlink()),"palette"in e&&(PALETTE=e.palette.split(/\s+/g),setlink()),$("#palette").val(PALETTE.reduce((e,n)=>e+" "+n)),globPolys=_.map(specs,e=>newgeneratePoly(e)),updateStats(),drawShape(),$("#spec").change(function(){return specs=$("#spec").val().split(/\s+/g).slice(0,2),globPolys=_.map(specs,e=>newgeneratePoly(e)),updateStats(),setlink(),drawShape()}),$("#palette").change(function(){return PALETTE=$(this).val().split(/\s+/g),setlink(),drawShape()}),$("#poly").mousewheel(function(n,e){return n.preventDefault(),perspective_scale*=(10+e)/10,drawShape()}),$("#poly").mousedown(function(n){n.preventDefault(),MOUSEDOWN=!0,LastMouseX=n.clientX-$(this).offset().left,LastMouseY=n.clientY-($(this).offset().top-$(window).scrollTop());const e=invperspT(LastMouseX,LastMouseY,_2d_x_offset,_2d_y_offset,persp_z_max,persp_z_min,persp_ratio,perspective_scale);return 0==0*(e[0]*e[1]*e[2])&&(LastSphVec=e),globlastRotM=clone(globRotM)}),$("#poly").mouseup(function(n){return n.preventDefault(),MOUSEDOWN=!1}),$("#poly").mouseleave(function(n){return n.preventDefault(),MOUSEDOWN=!1}),$("#poly").mousemove(function(n){if(n.preventDefault(),MOUSEDOWN){const e=n.clientX-$(this).offset().left,d=n.clientY-($(this).offset().top-$(window).scrollTop()),a=invperspT(e,d,_2d_x_offset,_2d_y_offset,persp_z_max,persp_z_min,persp_ratio,perspective_scale);return 0==0*(a[0]*a[1]*a[2])&&0==0*(LastSphVec[0]*LastSphVec[1]*LastSphVec[2])&&(globRotM=mm3(getVec2VecRotM(LastSphVec,a),globlastRotM)),drawShape()}}),$("#strokeonly").click(function(){return PaintMode="stroke",drawShape()}),$("#fillonly").click(function(){return PaintMode="fill",drawShape()}),$("#fillandstroke").click(function(){return PaintMode="fillstroke",drawShape()}),$("#siderot").click(function(){return globRotM=vec_rotm(PI/2,0,1,0),drawShape()}),$("#toprot").click(function(){return globRotM=vec_rotm(PI/2,1,0,0),drawShape()}),$("#frontrot").click(function(){return globRotM=rotm(0,0,0),drawShape()}),$("#pngsavebutton").click(function(){const e=$("#poly")[0],n=$("#spec").val().split(/\s+/g)[0],d=`polyhedronisme-${n.replace(/\([^\)]+\)/g,"")}.png`;return e.toBlobHD(e=>saveAs(e,d))}),$("#objsavebutton").click(function(){const e=globPolys[0].toOBJ(),n=$("#spec").val().split(/\s+/g)[0],d=`polyhedronisme-${n.replace(/\([^\)]+\)/g,"")}.obj`;return saveText(e,d)}),$("#x3dsavebutton").click(function(){const e=triangulate(globPolys[0],!0),n=e.toVRML(),d=$("#spec").val().split(/\s+/g)[0],a=`polyhedronisme-${d.replace(/\([^\)]+\)/g,"")}.wrl`;return saveText(n,a)})});